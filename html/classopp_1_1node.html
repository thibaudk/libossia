<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OSSIA: opp::node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OSSIA
   </div>
   <div id="projectbrief">Open Scenario System for Interactive Application</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classopp_1_1node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classopp_1_1node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">opp::node Class Reference<div class="ingroups"><a class="el" href="group___c_p_p98_a_p_i.html">C++98 API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The node class holds all ossia nodes and their optional parameters.  
 <a href="classopp_1_1node.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The node class holds all ossia nodes and their optional parameters. </p>
<p>The nodes in the device are simply called "nodes" in the API. Nodes are identified with the OSC syntax: /foo/bar. Nodes per se don't carry any value; they have to be extended with parameters to be able to send and receive messages. When multiple nodes with the same name are created, they will be appended instance numbers, separated with a dot. E.g. when duplicating the node /foo, its duplicates will be named /foo.1, /foo.2, etcâ€¦ This allows to have a cleaner representation of the address/namespace. <a href="https://ossia.github.io/images/NamespaceSlash.png">Namespace using slashes for instances</a> <a href="https://ossia.github.io/images/NamespaceDot.png">Namespace using dots for instances</a></p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classossia_1_1value.html" title="The value class. ">ossia::value</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86256fceb16c7fbf2cb157d2dd37d667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86256fceb16c7fbf2cb157d2dd37d667"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a86256fceb16c7fbf2cb157d2dd37d667">node</a> ()</td></tr>
<tr class="memdesc:a86256fceb16c7fbf2cb157d2dd37d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">node default constructor <br/></td></tr>
<tr class="separator:a86256fceb16c7fbf2cb157d2dd37d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09a0e279f76c938e55ce0c60c91b342"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac09a0e279f76c938e55ce0c60c91b342"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ac09a0e279f76c938e55ce0c60c91b342">node</a> (const <a class="el" href="classopp_1_1node.html">node</a> &amp;)</td></tr>
<tr class="memdesc:ac09a0e279f76c938e55ce0c60c91b342"><td class="mdescLeft">&#160;</td><td class="mdescRight">node copy constructor <br/></td></tr>
<tr class="separator:ac09a0e279f76c938e55ce0c60c91b342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f7569b5e9d35608e02f84bbc5ccb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a44f7569b5e9d35608e02f84bbc5ccb2e">operator=</a> (const <a class="el" href="classopp_1_1node.html">node</a> &amp;)</td></tr>
<tr class="memdesc:a44f7569b5e9d35608e02f84bbc5ccb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign the current node to another one  <a href="#a44f7569b5e9d35608e02f84bbc5ccb2e">More...</a><br/></td></tr>
<tr class="separator:a44f7569b5e9d35608e02f84bbc5ccb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0021f626ceabfeae2ec7086234e8c137"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0021f626ceabfeae2ec7086234e8c137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a0021f626ceabfeae2ec7086234e8c137">~node</a> ()</td></tr>
<tr class="memdesc:a0021f626ceabfeae2ec7086234e8c137"><td class="mdescLeft">&#160;</td><td class="mdescRight">node default destructor <br/></td></tr>
<tr class="separator:a0021f626ceabfeae2ec7086234e8c137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac720f0af630b8ee27619022d64c541b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ac720f0af630b8ee27619022d64c541b3">operator bool</a> () const </td></tr>
<tr class="memdesc:ac720f0af630b8ee27619022d64c541b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks is the node is valid  <a href="#ac720f0af630b8ee27619022d64c541b3">More...</a><br/></td></tr>
<tr class="separator:ac720f0af630b8ee27619022d64c541b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5435bebcbc494e8aedd13f327f18e208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5435bebcbc494e8aedd13f327f18e208"></a>
<a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a5435bebcbc494e8aedd13f327f18e208">parent</a> () const </td></tr>
<tr class="memdesc:a5435bebcbc494e8aedd13f327f18e208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parent of the node, or an invalid node if it is the root. <br/></td></tr>
<tr class="separator:a5435bebcbc494e8aedd13f327f18e208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dd382212d8d830084656efef3190aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad8dd382212d8d830084656efef3190aa">request_add_child</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ad8dd382212d8d830084656efef3190aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send to the device a request to add a node.  <a href="#ad8dd382212d8d830084656efef3190aa">More...</a><br/></td></tr>
<tr class="separator:ad8dd382212d8d830084656efef3190aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fe2cfb25a1fb0c26881876fdd1cb62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#af2fe2cfb25a1fb0c26881876fdd1cb62">request_remove_child</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:af2fe2cfb25a1fb0c26881876fdd1cb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send to the device a request to remove a node.  <a href="#af2fe2cfb25a1fb0c26881876fdd1cb62">More...</a><br/></td></tr>
<tr class="separator:af2fe2cfb25a1fb0c26881876fdd1cb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad309987a47ab61fd8023ebc50311e0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad309987a47ab61fd8023ebc50311e0b8">request_rename_child</a> (const std::string &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:ad309987a47ab61fd8023ebc50311e0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send to the device a request to rename a node.  <a href="#ad309987a47ab61fd8023ebc50311e0b8">More...</a><br/></td></tr>
<tr class="separator:ad309987a47ab61fd8023ebc50311e0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7cf6cff4f3bcf97e9dcf730d95707"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a59b7cf6cff4f3bcf97e9dcf730d95707">get_name</a> () const </td></tr>
<tr class="memdesc:a59b7cf6cff4f3bcf97e9dcf730d95707"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a node's name  <a href="#a59b7cf6cff4f3bcf97e9dcf730d95707">More...</a><br/></td></tr>
<tr class="separator:a59b7cf6cff4f3bcf97e9dcf730d95707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb66c9f170ebc2a704d7e45e25df6502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aeb66c9f170ebc2a704d7e45e25df6502">set_name</a> (std::string s)</td></tr>
<tr class="memdesc:aeb66c9f170ebc2a704d7e45e25df6502"><td class="mdescLeft">&#160;</td><td class="mdescRight">set or change a node's name  <a href="#aeb66c9f170ebc2a704d7e45e25df6502">More...</a><br/></td></tr>
<tr class="separator:aeb66c9f170ebc2a704d7e45e25df6502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e8b8155fcffada9be090368ade3c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a490e8b8155fcffada9be090368ade3c0">has_parameter</a> () const </td></tr>
<tr class="memdesc:a490e8b8155fcffada9be090368ade3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">does this node have a parameter ?  <a href="#a490e8b8155fcffada9be090368ade3c0">More...</a><br/></td></tr>
<tr class="separator:a490e8b8155fcffada9be090368ade3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0898906d92b158618fd53a4a4c4c6d3d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a0898906d92b158618fd53a4a4c4c6d3d">get_address</a> () const </td></tr>
<tr class="memdesc:a0898906d92b158618fd53a4a4c4c6d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get this node's OSC address  <a href="#a0898906d92b158618fd53a4a4c4c6d3d">More...</a><br/></td></tr>
<tr class="separator:a0898906d92b158618fd53a4a4c4c6d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26286850558fcaf8b304d7b753ee62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classopp_1_1node.html">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a4a26286850558fcaf8b304d7b753ee62">get_namespace</a> () const </td></tr>
<tr class="memdesc:a4a26286850558fcaf8b304d7b753ee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">return all children recursively by priority order  <a href="#a4a26286850558fcaf8b304d7b753ee62">More...</a><br/></td></tr>
<tr class="separator:a4a26286850558fcaf8b304d7b753ee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd7d5930a562174fec29e4ec3d4ecbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classopp_1_1node.html">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#afbd7d5930a562174fec29e4ec3d4ecbb">get_children</a> () const </td></tr>
<tr class="memdesc:afbd7d5930a562174fec29e4ec3d4ecbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all direct children (one level of hierarchy only)  <a href="#afbd7d5930a562174fec29e4ec3d4ecbb">More...</a><br/></td></tr>
<tr class="separator:afbd7d5930a562174fec29e4ec3d4ecbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9897c17755170e995a681b5bbf795eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a9897c17755170e995a681b5bbf795eab">find_child</a> (std::string addr) const </td></tr>
<tr class="memdesc:a9897c17755170e995a681b5bbf795eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds a child node by its name  <a href="#a9897c17755170e995a681b5bbf795eab">More...</a><br/></td></tr>
<tr class="separator:a9897c17755170e995a681b5bbf795eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d82ff02da7d00e7787481435596e78"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classopp_1_1node.html">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad5d82ff02da7d00e7787481435596e78">find_children</a> (std::string pattern) const </td></tr>
<tr class="memdesc:ad5d82ff02da7d00e7787481435596e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds children matching pattern  <a href="#ad5d82ff02da7d00e7787481435596e78">More...</a><br/></td></tr>
<tr class="separator:ad5d82ff02da7d00e7787481435596e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77be428f953d8d37cab93661d38e5167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a77be428f953d8d37cab93661d38e5167">remove_child</a> (std::string addr)</td></tr>
<tr class="memdesc:a77be428f953d8d37cab93661d38e5167"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a child node, described by its name  <a href="#a77be428f953d8d37cab93661d38e5167">More...</a><br/></td></tr>
<tr class="separator:a77be428f953d8d37cab93661d38e5167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32794730fe8f3e8f0121fd936712aa8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32794730fe8f3e8f0121fd936712aa8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a32794730fe8f3e8f0121fd936712aa8a">remove_children</a> ()</td></tr>
<tr class="memdesc:a32794730fe8f3e8f0121fd936712aa8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all children of the current node <br/></td></tr>
<tr class="separator:a32794730fe8f3e8f0121fd936712aa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb9c02fc885c71bb5eb27306c54270e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#adfb9c02fc885c71bb5eb27306c54270e">create_child</a> (std::string addr)</td></tr>
<tr class="memdesc:adfb9c02fc885c71bb5eb27306c54270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node to the current node this creates a "container", without a parameter, which can later be added with the set_(type) methods below  <a href="#adfb9c02fc885c71bb5eb27306c54270e">More...</a><br/></td></tr>
<tr class="separator:adfb9c02fc885c71bb5eb27306c54270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75278a72b02d719b463d6d4ec7b393a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad75278a72b02d719b463d6d4ec7b393a">set_impulse</a> ()</td></tr>
<tr class="memdesc:ad75278a72b02d719b463d6d4ec7b393a"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds an impulse parameter to the current node  <a href="#ad75278a72b02d719b463d6d4ec7b393a">More...</a><br/></td></tr>
<tr class="separator:ad75278a72b02d719b463d6d4ec7b393a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ba6cceb326ea94f58f30e5572d3c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aa4ba6cceb326ea94f58f30e5572d3c13">set_char</a> ()</td></tr>
<tr class="memdesc:aa4ba6cceb326ea94f58f30e5572d3c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a char parameter to the current node  <a href="#aa4ba6cceb326ea94f58f30e5572d3c13">More...</a><br/></td></tr>
<tr class="separator:aa4ba6cceb326ea94f58f30e5572d3c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d97abb3432934daaa5a091257cdff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a31d97abb3432934daaa5a091257cdff4">set_int</a> ()</td></tr>
<tr class="memdesc:a31d97abb3432934daaa5a091257cdff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds an int parameter to the current node  <a href="#a31d97abb3432934daaa5a091257cdff4">More...</a><br/></td></tr>
<tr class="separator:a31d97abb3432934daaa5a091257cdff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca270e3c6f937e83615a2e9993f672c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aca270e3c6f937e83615a2e9993f672c9">set_float</a> ()</td></tr>
<tr class="memdesc:aca270e3c6f937e83615a2e9993f672c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node  <a href="#aca270e3c6f937e83615a2e9993f672c9">More...</a><br/></td></tr>
<tr class="separator:aca270e3c6f937e83615a2e9993f672c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afaba8803b4476a1fb16c2900bf3559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a2afaba8803b4476a1fb16c2900bf3559">set_bool</a> ()</td></tr>
<tr class="memdesc:a2afaba8803b4476a1fb16c2900bf3559"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a bool parameter to the current node  <a href="#a2afaba8803b4476a1fb16c2900bf3559">More...</a><br/></td></tr>
<tr class="separator:a2afaba8803b4476a1fb16c2900bf3559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0d7da3e08a44a4f0f2ac4696f1c647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aef0d7da3e08a44a4f0f2ac4696f1c647">set_vec2f</a> ()</td></tr>
<tr class="memdesc:aef0d7da3e08a44a4f0f2ac4696f1c647"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec2f parameter to the current node  <a href="#aef0d7da3e08a44a4f0f2ac4696f1c647">More...</a><br/></td></tr>
<tr class="separator:aef0d7da3e08a44a4f0f2ac4696f1c647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30667c3507527de20248bc70854a1ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a30667c3507527de20248bc70854a1ebb">set_vec3f</a> ()</td></tr>
<tr class="memdesc:a30667c3507527de20248bc70854a1ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node  <a href="#a30667c3507527de20248bc70854a1ebb">More...</a><br/></td></tr>
<tr class="separator:a30667c3507527de20248bc70854a1ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b5c172a370ac74b898147be8c1a3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a36b5c172a370ac74b898147be8c1a3bd">set_vec4f</a> ()</td></tr>
<tr class="memdesc:a36b5c172a370ac74b898147be8c1a3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node  <a href="#a36b5c172a370ac74b898147be8c1a3bd">More...</a><br/></td></tr>
<tr class="separator:a36b5c172a370ac74b898147be8c1a3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539135ec52358a1ca5e02d3ca7b1be38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a539135ec52358a1ca5e02d3ca7b1be38">set_list</a> ()</td></tr>
<tr class="memdesc:a539135ec52358a1ca5e02d3ca7b1be38"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a list parameter to the current node  <a href="#a539135ec52358a1ca5e02d3ca7b1be38">More...</a><br/></td></tr>
<tr class="separator:a539135ec52358a1ca5e02d3ca7b1be38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c1f18160af863524ce33e5374f07a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae87c1f18160af863524ce33e5374f07a">set_string</a> ()</td></tr>
<tr class="memdesc:ae87c1f18160af863524ce33e5374f07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a string parameter to the current node  <a href="#ae87c1f18160af863524ce33e5374f07a">More...</a><br/></td></tr>
<tr class="separator:ae87c1f18160af863524ce33e5374f07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027606c2c4eafe0faaa217ce3911e52f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a027606c2c4eafe0faaa217ce3911e52f">set_buffer</a> ()</td></tr>
<tr class="memdesc:a027606c2c4eafe0faaa217ce3911e52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a buffer parameter to the current node  <a href="#a027606c2c4eafe0faaa217ce3911e52f">More...</a><br/></td></tr>
<tr class="separator:a027606c2c4eafe0faaa217ce3911e52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc366bf39b2877e507458f2b39b0432d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#afc366bf39b2877e507458f2b39b0432d">set_filepath</a> ()</td></tr>
<tr class="memdesc:afc366bf39b2877e507458f2b39b0432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a filepath parameter to the current node  <a href="#afc366bf39b2877e507458f2b39b0432d">More...</a><br/></td></tr>
<tr class="separator:afc366bf39b2877e507458f2b39b0432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490ef6a0aae958771f5956d6347b8000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a490ef6a0aae958771f5956d6347b8000">set_rgb</a> ()</td></tr>
<tr class="memdesc:a490ef6a0aae958771f5956d6347b8000"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the color.rgb unit  <a href="#a490ef6a0aae958771f5956d6347b8000">More...</a><br/></td></tr>
<tr class="separator:a490ef6a0aae958771f5956d6347b8000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15f01fb5dd52bc0a065174cbf11d64b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ac15f01fb5dd52bc0a065174cbf11d64b">set_rgba</a> ()</td></tr>
<tr class="memdesc:ac15f01fb5dd52bc0a065174cbf11d64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node, with the color.rgba unit  <a href="#ac15f01fb5dd52bc0a065174cbf11d64b">More...</a><br/></td></tr>
<tr class="separator:ac15f01fb5dd52bc0a065174cbf11d64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ac29541f4ef1d5780379a717421105"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a00ac29541f4ef1d5780379a717421105">set_argb</a> ()</td></tr>
<tr class="memdesc:a00ac29541f4ef1d5780379a717421105"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node, with the color.argb unit  <a href="#a00ac29541f4ef1d5780379a717421105">More...</a><br/></td></tr>
<tr class="separator:a00ac29541f4ef1d5780379a717421105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eef6047e8fa99aca4306438d51f5af1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a8eef6047e8fa99aca4306438d51f5af1">set_argb8</a> ()</td></tr>
<tr class="memdesc:a8eef6047e8fa99aca4306438d51f5af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node, with the color.argb8 unit  <a href="#a8eef6047e8fa99aca4306438d51f5af1">More...</a><br/></td></tr>
<tr class="separator:a8eef6047e8fa99aca4306438d51f5af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eee15d669d11fcae8ba65c2e85adbf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1eee15d669d11fcae8ba65c2e85adbf8">set_rgba8</a> ()</td></tr>
<tr class="memdesc:a1eee15d669d11fcae8ba65c2e85adbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node, with the color.rgba8 unit  <a href="#a1eee15d669d11fcae8ba65c2e85adbf8">More...</a><br/></td></tr>
<tr class="separator:a1eee15d669d11fcae8ba65c2e85adbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7815d8070ac3426c530d69033f06332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae7815d8070ac3426c530d69033f06332">set_hsv</a> ()</td></tr>
<tr class="memdesc:ae7815d8070ac3426c530d69033f06332"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the color.hsv unit  <a href="#ae7815d8070ac3426c530d69033f06332">More...</a><br/></td></tr>
<tr class="separator:ae7815d8070ac3426c530d69033f06332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b95aa1a538771848ff32631cb95207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a32b95aa1a538771848ff32631cb95207">set_cart2D</a> ()</td></tr>
<tr class="memdesc:a32b95aa1a538771848ff32631cb95207"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec2f parameter to the current node, with the position.cart2D unit  <a href="#a32b95aa1a538771848ff32631cb95207">More...</a><br/></td></tr>
<tr class="separator:a32b95aa1a538771848ff32631cb95207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0feb7b2d4c1911bfbdb649a6e5a923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ade0feb7b2d4c1911bfbdb649a6e5a923">set_cart3D</a> ()</td></tr>
<tr class="memdesc:ade0feb7b2d4c1911bfbdb649a6e5a923"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the position.cart3D unit  <a href="#ade0feb7b2d4c1911bfbdb649a6e5a923">More...</a><br/></td></tr>
<tr class="separator:ade0feb7b2d4c1911bfbdb649a6e5a923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b7aacf69c98576c086fbce78c98d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aa9b7aacf69c98576c086fbce78c98d0d">set_opengl</a> ()</td></tr>
<tr class="memdesc:aa9b7aacf69c98576c086fbce78c98d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the position.openGL unit (aka X, Y, Z)  <a href="#aa9b7aacf69c98576c086fbce78c98d0d">More...</a><br/></td></tr>
<tr class="separator:aa9b7aacf69c98576c086fbce78c98d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d7ddf143b1e5959ffe75fd4bfd5fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a69d7ddf143b1e5959ffe75fd4bfd5fc3">set_polar</a> ()</td></tr>
<tr class="memdesc:a69d7ddf143b1e5959ffe75fd4bfd5fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec2f parameter to the current node, with the position.polar unit  <a href="#a69d7ddf143b1e5959ffe75fd4bfd5fc3">More...</a><br/></td></tr>
<tr class="separator:a69d7ddf143b1e5959ffe75fd4bfd5fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf5c36e2f1e5ad68243f0ea84e11af9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a2bf5c36e2f1e5ad68243f0ea84e11af9">set_spherical</a> ()</td></tr>
<tr class="memdesc:a2bf5c36e2f1e5ad68243f0ea84e11af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the position.spherical unit (aka aed)  <a href="#a2bf5c36e2f1e5ad68243f0ea84e11af9">More...</a><br/></td></tr>
<tr class="separator:a2bf5c36e2f1e5ad68243f0ea84e11af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e4ba44250360236009803d8ae265c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad4e4ba44250360236009803d8ae265c7">set_cylindrical</a> ()</td></tr>
<tr class="memdesc:ad4e4ba44250360236009803d8ae265c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the position.cylindrical unit (aka daz)  <a href="#ad4e4ba44250360236009803d8ae265c7">More...</a><br/></td></tr>
<tr class="separator:ad4e4ba44250360236009803d8ae265c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d42ade9b80e91ea70f0e386059cbae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a2d42ade9b80e91ea70f0e386059cbae8">set_angle_radian</a> ()</td></tr>
<tr class="memdesc:a2d42ade9b80e91ea70f0e386059cbae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">cadds a vec3f parameter to the current node, with the angle.radian unit  <a href="#a2d42ade9b80e91ea70f0e386059cbae8">More...</a><br/></td></tr>
<tr class="separator:a2d42ade9b80e91ea70f0e386059cbae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2976c4fbf366ec584f784c4520cc0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ac2976c4fbf366ec584f784c4520cc0f0">set_angle_degree</a> ()</td></tr>
<tr class="memdesc:ac2976c4fbf366ec584f784c4520cc0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with theangle.radian unit  <a href="#ac2976c4fbf366ec584f784c4520cc0f0">More...</a><br/></td></tr>
<tr class="separator:ac2976c4fbf366ec584f784c4520cc0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b117ed3ec9f7b647ca11f8237a1c1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1b117ed3ec9f7b647ca11f8237a1c1d6">set_quaternion</a> ()</td></tr>
<tr class="memdesc:a1b117ed3ec9f7b647ca11f8237a1c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node, with the orientation.quaternion unit  <a href="#a1b117ed3ec9f7b647ca11f8237a1c1d6">More...</a><br/></td></tr>
<tr class="separator:a1b117ed3ec9f7b647ca11f8237a1c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8954fca7c67f310b91ac91e8986295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#abe8954fca7c67f310b91ac91e8986295">set_euler</a> ()</td></tr>
<tr class="memdesc:abe8954fca7c67f310b91ac91e8986295"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec3f parameter to the current node, with the orientation.euler unit (aka Euler angles)  <a href="#abe8954fca7c67f310b91ac91e8986295">More...</a><br/></td></tr>
<tr class="separator:abe8954fca7c67f310b91ac91e8986295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd4da261c09419e2cdd0b9f5d271852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aefd4da261c09419e2cdd0b9f5d271852">set_axis</a> ()</td></tr>
<tr class="memdesc:aefd4da261c09419e2cdd0b9f5d271852"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a vec4f parameter to the current node, with the orientation.axis unit  <a href="#aefd4da261c09419e2cdd0b9f5d271852">More...</a><br/></td></tr>
<tr class="separator:aefd4da261c09419e2cdd0b9f5d271852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35739d903577f2f66f864859731f088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad35739d903577f2f66f864859731f088">set_decibel</a> ()</td></tr>
<tr class="memdesc:ad35739d903577f2f66f864859731f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node, with the gain.decibel unit  <a href="#ad35739d903577f2f66f864859731f088">More...</a><br/></td></tr>
<tr class="separator:ad35739d903577f2f66f864859731f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c28b31d17a1b1ea7aec145273bbde0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a75c28b31d17a1b1ea7aec145273bbde0">set_midigain</a> ()</td></tr>
<tr class="memdesc:a75c28b31d17a1b1ea7aec145273bbde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node, with the gain.midigain unit  <a href="#a75c28b31d17a1b1ea7aec145273bbde0">More...</a><br/></td></tr>
<tr class="separator:a75c28b31d17a1b1ea7aec145273bbde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ad7e58b22a66c466d825441452d378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae5ad7e58b22a66c466d825441452d378">set_linear</a> ()</td></tr>
<tr class="memdesc:ae5ad7e58b22a66c466d825441452d378"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node, with the gain.linear unit  <a href="#ae5ad7e58b22a66c466d825441452d378">More...</a><br/></td></tr>
<tr class="separator:ae5ad7e58b22a66c466d825441452d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66b95bce65be84941e4d05de8ee059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#acb66b95bce65be84941e4d05de8ee059">set_frequency</a> ()</td></tr>
<tr class="memdesc:acb66b95bce65be84941e4d05de8ee059"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node, with the time.frequency unit  <a href="#acb66b95bce65be84941e4d05de8ee059">More...</a><br/></td></tr>
<tr class="separator:acb66b95bce65be84941e4d05de8ee059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4d460ee0825745cac5b990360aa18b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1b4d460ee0825745cac5b990360aa18b">set_midi_pitch</a> ()</td></tr>
<tr class="memdesc:a1b4d460ee0825745cac5b990360aa18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node, with the time.midi_pitch unit  <a href="#a1b4d460ee0825745cac5b990360aa18b">More...</a><br/></td></tr>
<tr class="separator:a1b4d460ee0825745cac5b990360aa18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6694dae2bd1186c7ed24051beae680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a3a6694dae2bd1186c7ed24051beae680">set_bpm</a> ()</td></tr>
<tr class="memdesc:a3a6694dae2bd1186c7ed24051beae680"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a float parameter to the current node, with the time.bpm unit  <a href="#a3a6694dae2bd1186c7ed24051beae680">More...</a><br/></td></tr>
<tr class="separator:a3a6694dae2bd1186c7ed24051beae680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3bf8a9cd2823f4cd795cf107a0d119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1c3bf8a9cd2823f4cd795cf107a0d119">create_void</a> (std::string addr)</td></tr>
<tr class="memdesc:a1c3bf8a9cd2823f4cd795cf107a0d119"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with the name, and without parameter  <a href="#a1c3bf8a9cd2823f4cd795cf107a0d119">More...</a><br/></td></tr>
<tr class="separator:a1c3bf8a9cd2823f4cd795cf107a0d119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb736d9ea4ef15ef0e4c4c87371e4db3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aeb736d9ea4ef15ef0e4c4c87371e4db3">create_impulse</a> (std::string addr)</td></tr>
<tr class="memdesc:aeb736d9ea4ef15ef0e4c4c87371e4db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and an impulse parameter  <a href="#aeb736d9ea4ef15ef0e4c4c87371e4db3">More...</a><br/></td></tr>
<tr class="separator:aeb736d9ea4ef15ef0e4c4c87371e4db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46e370c1786d6a4964993bee6ceb485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ab46e370c1786d6a4964993bee6ceb485">create_char</a> (std::string addr)</td></tr>
<tr class="memdesc:ab46e370c1786d6a4964993bee6ceb485"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a char parameter  <a href="#ab46e370c1786d6a4964993bee6ceb485">More...</a><br/></td></tr>
<tr class="separator:ab46e370c1786d6a4964993bee6ceb485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb77902e4063de66933787f41c4eaa45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#adb77902e4063de66933787f41c4eaa45">create_int</a> (std::string addr)</td></tr>
<tr class="memdesc:adb77902e4063de66933787f41c4eaa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and an int parameter  <a href="#adb77902e4063de66933787f41c4eaa45">More...</a><br/></td></tr>
<tr class="separator:adb77902e4063de66933787f41c4eaa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db8d89f5bca2c401c046346519edbae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a4db8d89f5bca2c401c046346519edbae">create_float</a> (std::string addr)</td></tr>
<tr class="memdesc:a4db8d89f5bca2c401c046346519edbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter  <a href="#a4db8d89f5bca2c401c046346519edbae">More...</a><br/></td></tr>
<tr class="separator:a4db8d89f5bca2c401c046346519edbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc4bbe26e5300368bea361276e4cc22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a3fc4bbe26e5300368bea361276e4cc22">create_bool</a> (std::string addr)</td></tr>
<tr class="memdesc:a3fc4bbe26e5300368bea361276e4cc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a bool parameter  <a href="#a3fc4bbe26e5300368bea361276e4cc22">More...</a><br/></td></tr>
<tr class="separator:a3fc4bbe26e5300368bea361276e4cc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46028a8cdf143ac6812ddaf1973fe154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a46028a8cdf143ac6812ddaf1973fe154">create_vec2f</a> (std::string addr)</td></tr>
<tr class="memdesc:a46028a8cdf143ac6812ddaf1973fe154"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec2f parameter  <a href="#a46028a8cdf143ac6812ddaf1973fe154">More...</a><br/></td></tr>
<tr class="separator:a46028a8cdf143ac6812ddaf1973fe154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84877d7ecdc5bd71cbe97f0cce6f6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad84877d7ecdc5bd71cbe97f0cce6f6ba">create_vec3f</a> (std::string addr)</td></tr>
<tr class="memdesc:ad84877d7ecdc5bd71cbe97f0cce6f6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter  <a href="#ad84877d7ecdc5bd71cbe97f0cce6f6ba">More...</a><br/></td></tr>
<tr class="separator:ad84877d7ecdc5bd71cbe97f0cce6f6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9ebd44ba021e25993cbd2206f095e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aee9ebd44ba021e25993cbd2206f095e5">create_vec4f</a> (std::string addr)</td></tr>
<tr class="memdesc:aee9ebd44ba021e25993cbd2206f095e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter  <a href="#aee9ebd44ba021e25993cbd2206f095e5">More...</a><br/></td></tr>
<tr class="separator:aee9ebd44ba021e25993cbd2206f095e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ef9668c57839687b1af326e7e060d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad6ef9668c57839687b1af326e7e060d0">create_list</a> (std::string addr)</td></tr>
<tr class="memdesc:ad6ef9668c57839687b1af326e7e060d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a list parameter  <a href="#ad6ef9668c57839687b1af326e7e060d0">More...</a><br/></td></tr>
<tr class="separator:ad6ef9668c57839687b1af326e7e060d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28c792aebb371a1fd43131afc3c01bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae28c792aebb371a1fd43131afc3c01bc">create_string</a> (std::string addr)</td></tr>
<tr class="memdesc:ae28c792aebb371a1fd43131afc3c01bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a string parameter  <a href="#ae28c792aebb371a1fd43131afc3c01bc">More...</a><br/></td></tr>
<tr class="separator:ae28c792aebb371a1fd43131afc3c01bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059e3f624fdab4a0fe2016324c172b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a059e3f624fdab4a0fe2016324c172b5d">create_buffer</a> (std::string addr)</td></tr>
<tr class="memdesc:a059e3f624fdab4a0fe2016324c172b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a buffer parameter  <a href="#a059e3f624fdab4a0fe2016324c172b5d">More...</a><br/></td></tr>
<tr class="separator:a059e3f624fdab4a0fe2016324c172b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89837e94060208ccac7b52d89be58bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a89837e94060208ccac7b52d89be58bdf">create_filepath</a> (std::string addr)</td></tr>
<tr class="memdesc:a89837e94060208ccac7b52d89be58bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a filepath parameter  <a href="#a89837e94060208ccac7b52d89be58bdf">More...</a><br/></td></tr>
<tr class="separator:a89837e94060208ccac7b52d89be58bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6f08c22080d5ae627b1dff18b1bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a9bb6f08c22080d5ae627b1dff18b1bf7">create_rgb</a> (std::string addr)</td></tr>
<tr class="memdesc:a9bb6f08c22080d5ae627b1dff18b1bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the color.rgb unit  <a href="#a9bb6f08c22080d5ae627b1dff18b1bf7">More...</a><br/></td></tr>
<tr class="separator:a9bb6f08c22080d5ae627b1dff18b1bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada68b7aff298c4f2b3369f2d4c3f59f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ada68b7aff298c4f2b3369f2d4c3f59f6">create_rgba</a> (std::string addr)</td></tr>
<tr class="memdesc:ada68b7aff298c4f2b3369f2d4c3f59f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter with the color.rgba unit  <a href="#ada68b7aff298c4f2b3369f2d4c3f59f6">More...</a><br/></td></tr>
<tr class="separator:ada68b7aff298c4f2b3369f2d4c3f59f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3caafad80f96913de7848afb7d4b942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#af3caafad80f96913de7848afb7d4b942">create_rgba8</a> (std::string addr)</td></tr>
<tr class="memdesc:af3caafad80f96913de7848afb7d4b942"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter with the color.rgba8 unit  <a href="#af3caafad80f96913de7848afb7d4b942">More...</a><br/></td></tr>
<tr class="separator:af3caafad80f96913de7848afb7d4b942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711c0b9c1acb134946e7ec96d53aa489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a711c0b9c1acb134946e7ec96d53aa489">create_argb</a> (std::string addr)</td></tr>
<tr class="memdesc:a711c0b9c1acb134946e7ec96d53aa489"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter with the color.argb unit  <a href="#a711c0b9c1acb134946e7ec96d53aa489">More...</a><br/></td></tr>
<tr class="separator:a711c0b9c1acb134946e7ec96d53aa489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f554835042c0baa86dc6ce1b3035b1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a5f554835042c0baa86dc6ce1b3035b1c">create_argb8</a> (std::string addr)</td></tr>
<tr class="memdesc:a5f554835042c0baa86dc6ce1b3035b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter with the color.argb8 unit  <a href="#a5f554835042c0baa86dc6ce1b3035b1c">More...</a><br/></td></tr>
<tr class="separator:a5f554835042c0baa86dc6ce1b3035b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257218faa82e5ffd4196e285232e3f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a257218faa82e5ffd4196e285232e3f3d">create_hsv</a> (std::string addr)</td></tr>
<tr class="memdesc:a257218faa82e5ffd4196e285232e3f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the color.hsv unit  <a href="#a257218faa82e5ffd4196e285232e3f3d">More...</a><br/></td></tr>
<tr class="separator:a257218faa82e5ffd4196e285232e3f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97a8b0d8efb3546e7f01ba71755d9c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad97a8b0d8efb3546e7f01ba71755d9c2">create_cart2D</a> (std::string addr)</td></tr>
<tr class="memdesc:ad97a8b0d8efb3546e7f01ba71755d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec2f parameter with the position.cart2D unit (aka xy)  <a href="#ad97a8b0d8efb3546e7f01ba71755d9c2">More...</a><br/></td></tr>
<tr class="separator:ad97a8b0d8efb3546e7f01ba71755d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2b1b7b26fdca0bab2767b2dd08e3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aee2b1b7b26fdca0bab2767b2dd08e3f7">create_cart3D</a> (std::string addr)</td></tr>
<tr class="memdesc:aee2b1b7b26fdca0bab2767b2dd08e3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the position.cart3D unit (aka XYZ)  <a href="#aee2b1b7b26fdca0bab2767b2dd08e3f7">More...</a><br/></td></tr>
<tr class="separator:aee2b1b7b26fdca0bab2767b2dd08e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3517a8b4ed5089aac17f7d2eacb8ccef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a3517a8b4ed5089aac17f7d2eacb8ccef">create_opengl</a> (std::string addr)</td></tr>
<tr class="memdesc:a3517a8b4ed5089aac17f7d2eacb8ccef"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the position.openGL unit (aka xyz)  <a href="#a3517a8b4ed5089aac17f7d2eacb8ccef">More...</a><br/></td></tr>
<tr class="separator:a3517a8b4ed5089aac17f7d2eacb8ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2170924f3a93e3710642ee3bf7fe19a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad2170924f3a93e3710642ee3bf7fe19a">create_polar</a> (std::string addr)</td></tr>
<tr class="memdesc:ad2170924f3a93e3710642ee3bf7fe19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec2f parameter with the position.polar unit (aka rp)  <a href="#ad2170924f3a93e3710642ee3bf7fe19a">More...</a><br/></td></tr>
<tr class="separator:ad2170924f3a93e3710642ee3bf7fe19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245fb71f60d9fb96698a2d6535ab2e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a245fb71f60d9fb96698a2d6535ab2e2c">create_spherical</a> (std::string addr)</td></tr>
<tr class="memdesc:a245fb71f60d9fb96698a2d6535ab2e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the position.spherical unit (aka rtp)  <a href="#a245fb71f60d9fb96698a2d6535ab2e2c">More...</a><br/></td></tr>
<tr class="separator:a245fb71f60d9fb96698a2d6535ab2e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1d806fcbed4c6c95b8af2b6f2cc1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1f1d806fcbed4c6c95b8af2b6f2cc1b6">create_cylindrical</a> (std::string addr)</td></tr>
<tr class="memdesc:a1f1d806fcbed4c6c95b8af2b6f2cc1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the position.cylindrical unit (aka rpz)  <a href="#a1f1d806fcbed4c6c95b8af2b6f2cc1b6">More...</a><br/></td></tr>
<tr class="separator:a1f1d806fcbed4c6c95b8af2b6f2cc1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e7499f93905d61fbf13ff2bcdb820c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a18e7499f93905d61fbf13ff2bcdb820c">create_angle_radian</a> (std::string addr)</td></tr>
<tr class="memdesc:a18e7499f93905d61fbf13ff2bcdb820c"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the angle.radian unit  <a href="#a18e7499f93905d61fbf13ff2bcdb820c">More...</a><br/></td></tr>
<tr class="separator:a18e7499f93905d61fbf13ff2bcdb820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7078259ab9d448dab27d3f1cf7768b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a7078259ab9d448dab27d3f1cf7768b4a">create_angle_degree</a> (std::string addr)</td></tr>
<tr class="memdesc:a7078259ab9d448dab27d3f1cf7768b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the angle.radian unit  <a href="#a7078259ab9d448dab27d3f1cf7768b4a">More...</a><br/></td></tr>
<tr class="separator:a7078259ab9d448dab27d3f1cf7768b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d88c575f9ae9b85d458286cd0a9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a568d88c575f9ae9b85d458286cd0a9d8">create_quaternion</a> (std::string addr)</td></tr>
<tr class="memdesc:a568d88c575f9ae9b85d458286cd0a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter with the orientation.quaternion unit  <a href="#a568d88c575f9ae9b85d458286cd0a9d8">More...</a><br/></td></tr>
<tr class="separator:a568d88c575f9ae9b85d458286cd0a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5110b70106cf9b8a7cf7bcc120e7067d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a5110b70106cf9b8a7cf7bcc120e7067d">create_euler</a> (std::string addr)</td></tr>
<tr class="memdesc:a5110b70106cf9b8a7cf7bcc120e7067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec3f parameter with the orientation.euler unit (aka Euler angles)  <a href="#a5110b70106cf9b8a7cf7bcc120e7067d">More...</a><br/></td></tr>
<tr class="separator:a5110b70106cf9b8a7cf7bcc120e7067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0b798db44c974a41e611fe0997bde7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a8a0b798db44c974a41e611fe0997bde7">create_axis</a> (std::string addr)</td></tr>
<tr class="memdesc:a8a0b798db44c974a41e611fe0997bde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a vec4f parameter with the orientation.axis unit (aka xyza)  <a href="#a8a0b798db44c974a41e611fe0997bde7">More...</a><br/></td></tr>
<tr class="separator:a8a0b798db44c974a41e611fe0997bde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6fdd94ded768b7fdf2ec119215d870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#afa6fdd94ded768b7fdf2ec119215d870">create_decibel</a> (std::string addr)</td></tr>
<tr class="memdesc:afa6fdd94ded768b7fdf2ec119215d870"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the gain.decibel unit  <a href="#afa6fdd94ded768b7fdf2ec119215d870">More...</a><br/></td></tr>
<tr class="separator:afa6fdd94ded768b7fdf2ec119215d870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a5703d04ae9da8a7bc3c61c6b9f295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ac5a5703d04ae9da8a7bc3c61c6b9f295">create_midigain</a> (std::string addr)</td></tr>
<tr class="memdesc:ac5a5703d04ae9da8a7bc3c61c6b9f295"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the gain.midigain unit in the [0 127) range  <a href="#ac5a5703d04ae9da8a7bc3c61c6b9f295">More...</a><br/></td></tr>
<tr class="separator:ac5a5703d04ae9da8a7bc3c61c6b9f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b20d2dd52b82f30dd8a3ab3648027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a324b20d2dd52b82f30dd8a3ab3648027">create_linear</a> (std::string addr)</td></tr>
<tr class="memdesc:a324b20d2dd52b82f30dd8a3ab3648027"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the gain.linear unit in the [0. 1.) range  <a href="#a324b20d2dd52b82f30dd8a3ab3648027">More...</a><br/></td></tr>
<tr class="separator:a324b20d2dd52b82f30dd8a3ab3648027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94434d277319ca9634c7606fd9e4de7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a94434d277319ca9634c7606fd9e4de7a">create_frequency</a> (std::string addr)</td></tr>
<tr class="memdesc:a94434d277319ca9634c7606fd9e4de7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the time.frequency unit  <a href="#a94434d277319ca9634c7606fd9e4de7a">More...</a><br/></td></tr>
<tr class="separator:a94434d277319ca9634c7606fd9e4de7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9710c3a9d3e08e321a60504412aab10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a9710c3a9d3e08e321a60504412aab10a">create_midi_pitch</a> (std::string addr)</td></tr>
<tr class="memdesc:a9710c3a9d3e08e321a60504412aab10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the time.midi_pitch unit  <a href="#a9710c3a9d3e08e321a60504412aab10a">More...</a><br/></td></tr>
<tr class="separator:a9710c3a9d3e08e321a60504412aab10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f659cd38bff0e580720c5ecd28112b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a6f659cd38bff0e580720c5ecd28112b8">create_bpm</a> (std::string addr)</td></tr>
<tr class="memdesc:a6f659cd38bff0e580720c5ecd28112b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a child node with tne given name, and a float parameter with the time.bpm unit  <a href="#a6f659cd38bff0e580720c5ecd28112b8">More...</a><br/></td></tr>
<tr class="separator:a6f659cd38bff0e580720c5ecd28112b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08508d1e965f2df41ae7c988bce9306e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a08508d1e965f2df41ae7c988bce9306e">set_value</a> (<a class="el" href="classopp_1_1value.html">opp::value</a> v)</td></tr>
<tr class="memdesc:a08508d1e965f2df41ae7c988bce9306e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the node's parameter's value  <a href="#a08508d1e965f2df41ae7c988bce9306e">More...</a><br/></td></tr>
<tr class="separator:a08508d1e965f2df41ae7c988bce9306e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38746c9de30e9f3a066ac22d625367a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae38746c9de30e9f3a066ac22d625367a">get_value</a> () const </td></tr>
<tr class="memdesc:ae38746c9de30e9f3a066ac22d625367a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get this node's (local) parameter's value  <a href="#ae38746c9de30e9f3a066ac22d625367a">More...</a><br/></td></tr>
<tr class="separator:ae38746c9de30e9f3a066ac22d625367a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79bf1415b202d1704d4e13569be8a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#af79bf1415b202d1704d4e13569be8a00">fetch_value</a> () const </td></tr>
<tr class="memdesc:af79bf1415b202d1704d4e13569be8a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">fetch this node's parameter's value over the network:  <a href="#af79bf1415b202d1704d4e13569be8a00">More...</a><br/></td></tr>
<tr class="separator:af79bf1415b202d1704d4e13569be8a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bd2b81241d90f8b3e2c5e223063442"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopp_1_1callback__index.html">callback_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a80bd2b81241d90f8b3e2c5e223063442">set_value_callback</a> (<a class="el" href="namespaceopp.html#a0a4d1fcb27d12c990c5f5fe78a7c0b35">value_callback</a> c, void *ctx)</td></tr>
<tr class="memdesc:a80bd2b81241d90f8b3e2c5e223063442"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a callback allowing to listen to this value  <a href="#a80bd2b81241d90f8b3e2c5e223063442">More...</a><br/></td></tr>
<tr class="separator:a80bd2b81241d90f8b3e2c5e223063442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22be6e0f63fad29a8c34803aa8102986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a22be6e0f63fad29a8c34803aa8102986">remove_value_callback</a> (<a class="el" href="structopp_1_1callback__index.html">callback_index</a> idx)</td></tr>
<tr class="memdesc:a22be6e0f63fad29a8c34803aa8102986"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a value_callback, previously set with <a class="el" href="classopp_1_1node.html#a80bd2b81241d90f8b3e2c5e223063442" title="sets a callback allowing to listen to this value ">set_value_callback()</a>  <a href="#a22be6e0f63fad29a8c34803aa8102986">More...</a><br/></td></tr>
<tr class="separator:a22be6e0f63fad29a8c34803aa8102986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff22b0fcbb21f65b0b6e7a87e306ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a2ff22b0fcbb21f65b0b6e7a87e306ad1">set_access</a> (<a class="el" href="namespaceopp.html#a8b693d7ac4659eabc37b56a8e8565ff3">access_mode</a> v)</td></tr>
<tr class="memdesc:a2ff22b0fcbb21f65b0b6e7a87e306ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the access_mode attribute of this node's parameter  <a href="#a2ff22b0fcbb21f65b0b6e7a87e306ad1">More...</a><br/></td></tr>
<tr class="separator:a2ff22b0fcbb21f65b0b6e7a87e306ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ef5059c3ecbbe039ab77ae4f6fbeec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopp.html#a8b693d7ac4659eabc37b56a8e8565ff3">access_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a94ef5059c3ecbbe039ab77ae4f6fbeec">get_access</a> () const </td></tr>
<tr class="memdesc:a94ef5059c3ecbbe039ab77ae4f6fbeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the access_mode attribute of this node's parameter  <a href="#a94ef5059c3ecbbe039ab77ae4f6fbeec">More...</a><br/></td></tr>
<tr class="separator:a94ef5059c3ecbbe039ab77ae4f6fbeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0ba8f99bc33e21d8b6665f495dc039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#afe0ba8f99bc33e21d8b6665f495dc039">set_min</a> (<a class="el" href="classopp_1_1value.html">opp::value</a> min)</td></tr>
<tr class="memdesc:afe0ba8f99bc33e21d8b6665f495dc039"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the 'min' attribute of this node's parameter (minimum value)  <a href="#afe0ba8f99bc33e21d8b6665f495dc039">More...</a><br/></td></tr>
<tr class="separator:afe0ba8f99bc33e21d8b6665f495dc039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcbfaecbef8831f2788684924530d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aadcbfaecbef8831f2788684924530d0a">get_min</a> () const </td></tr>
<tr class="memdesc:aadcbfaecbef8831f2788684924530d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the 'min' attribute of this node's parameter (minimum value)  <a href="#aadcbfaecbef8831f2788684924530d0a">More...</a><br/></td></tr>
<tr class="separator:aadcbfaecbef8831f2788684924530d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35bdf42f8c92e33b749e01f5c2298e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad35bdf42f8c92e33b749e01f5c2298e2">set_max</a> (<a class="el" href="classopp_1_1value.html">opp::value</a> max)</td></tr>
<tr class="memdesc:ad35bdf42f8c92e33b749e01f5c2298e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the 'max' attribute of this node's parameter (maximum value)  <a href="#ad35bdf42f8c92e33b749e01f5c2298e2">More...</a><br/></td></tr>
<tr class="separator:ad35bdf42f8c92e33b749e01f5c2298e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb5eb32560bd54fafd8ee5ff64546d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a6bdb5eb32560bd54fafd8ee5ff64546d">get_max</a> () const </td></tr>
<tr class="memdesc:a6bdb5eb32560bd54fafd8ee5ff64546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the 'max' attribute of this node's parameter (maximum value)  <a href="#a6bdb5eb32560bd54fafd8ee5ff64546d">More...</a><br/></td></tr>
<tr class="separator:a6bdb5eb32560bd54fafd8ee5ff64546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e2c36e5563f9b6477dde20307ef4a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#af8e2c36e5563f9b6477dde20307ef4a3">set_accepted_values</a> (std::vector&lt; <a class="el" href="classopp_1_1value.html">opp::value</a> &gt; v)</td></tr>
<tr class="memdesc:af8e2c36e5563f9b6477dde20307ef4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a list of the values accepted by this node's parameter ("values" attribute)  <a href="#af8e2c36e5563f9b6477dde20307ef4a3">More...</a><br/></td></tr>
<tr class="separator:af8e2c36e5563f9b6477dde20307ef4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a6a123f32e57763a5b9c9826f6bdfc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classopp_1_1value.html">opp::value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a75a6a123f32e57763a5b9c9826f6bdfc">get_accepted_values</a> () const </td></tr>
<tr class="memdesc:a75a6a123f32e57763a5b9c9826f6bdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets a list of the values accepted by this node's parameter ("values" attribute)  <a href="#a75a6a123f32e57763a5b9c9826f6bdfc">More...</a><br/></td></tr>
<tr class="separator:a75a6a123f32e57763a5b9c9826f6bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f33371530f5793628bbfc71d96c1af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a9f33371530f5793628bbfc71d96c1af5">set_bounding</a> (<a class="el" href="namespaceopp.html#a928d0c64a8d475a1f454ed1b140ca954">bounding_mode</a> v)</td></tr>
<tr class="memdesc:a9f33371530f5793628bbfc71d96c1af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the bounding_mode attribute of this node's parameter  <a href="#a9f33371530f5793628bbfc71d96c1af5">More...</a><br/></td></tr>
<tr class="separator:a9f33371530f5793628bbfc71d96c1af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb32fcd277d7ee4f908e241fb8f86157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopp.html#a928d0c64a8d475a1f454ed1b140ca954">bounding_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#afb32fcd277d7ee4f908e241fb8f86157">get_bounding</a> () const </td></tr>
<tr class="memdesc:afb32fcd277d7ee4f908e241fb8f86157"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the bounding_mode attribute of this node's parameter  <a href="#afb32fcd277d7ee4f908e241fb8f86157">More...</a><br/></td></tr>
<tr class="separator:afb32fcd277d7ee4f908e241fb8f86157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b06de6a111af5996d4216ee8c8392c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a5b06de6a111af5996d4216ee8c8392c1">set_unit</a> (std::string v)</td></tr>
<tr class="memdesc:a5b06de6a111af5996d4216ee8c8392c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the unit attribute of this node's parameter  <a href="#a5b06de6a111af5996d4216ee8c8392c1">More...</a><br/></td></tr>
<tr class="separator:a5b06de6a111af5996d4216ee8c8392c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ebec6efacf660025c4efa95473873"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a207ebec6efacf660025c4efa95473873">get_unit</a> () const </td></tr>
<tr class="memdesc:a207ebec6efacf660025c4efa95473873"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the unit of this node's parameter  <a href="#a207ebec6efacf660025c4efa95473873">More...</a><br/></td></tr>
<tr class="separator:a207ebec6efacf660025c4efa95473873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57cbd951ec099c0c30e31cfca40e392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae57cbd951ec099c0c30e31cfca40e392">set_default_value</a> (<a class="el" href="classopp_1_1value.html">value</a> v)</td></tr>
<tr class="memdesc:ae57cbd951ec099c0c30e31cfca40e392"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the default_value attribute of this node's parameter  <a href="#ae57cbd951ec099c0c30e31cfca40e392">More...</a><br/></td></tr>
<tr class="separator:ae57cbd951ec099c0c30e31cfca40e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958c29f69d0687edd03df7470c343fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a958c29f69d0687edd03df7470c343fca">get_default_value</a> ()</td></tr>
<tr class="memdesc:a958c29f69d0687edd03df7470c343fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the default_value attribute of this node's parameter  <a href="#a958c29f69d0687edd03df7470c343fca">More...</a><br/></td></tr>
<tr class="separator:a958c29f69d0687edd03df7470c343fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e29de264900d7392e37eafecaab1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a168e29de264900d7392e37eafecaab1d">set_repetition_filter</a> (bool v)</td></tr>
<tr class="memdesc:a168e29de264900d7392e37eafecaab1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the repetition_filter attribute of this node's parameter  <a href="#a168e29de264900d7392e37eafecaab1d">More...</a><br/></td></tr>
<tr class="separator:a168e29de264900d7392e37eafecaab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bf84f55897dafa4ab2b6f431329a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a03bf84f55897dafa4ab2b6f431329a4e">get_repetition_filter</a> () const </td></tr>
<tr class="memdesc:a03bf84f55897dafa4ab2b6f431329a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the repetition_filter attribute of this node's parameter  <a href="#a03bf84f55897dafa4ab2b6f431329a4e">More...</a><br/></td></tr>
<tr class="separator:a03bf84f55897dafa4ab2b6f431329a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e16899e2e14b3ec239ec2222cc2872d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a2e16899e2e14b3ec239ec2222cc2872d">set_refresh_rate</a> (int v)</td></tr>
<tr class="memdesc:a2e16899e2e14b3ec239ec2222cc2872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the refresh_rate attribute of this node's parameter  <a href="#a2e16899e2e14b3ec239ec2222cc2872d">More...</a><br/></td></tr>
<tr class="separator:a2e16899e2e14b3ec239ec2222cc2872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2870761c0afafd835ce34a77a574b97d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a2870761c0afafd835ce34a77a574b97d">unset_refresh_rate</a> ()</td></tr>
<tr class="memdesc:a2870761c0afafd835ce34a77a574b97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsets the refresh_rate attribute of this node's parameter  <a href="#a2870761c0afafd835ce34a77a574b97d">More...</a><br/></td></tr>
<tr class="separator:a2870761c0afafd835ce34a77a574b97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d625eb609e0d9eb8b0a5f46aaa5cfe4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a8d625eb609e0d9eb8b0a5f46aaa5cfe4">get_refresh_rate</a> ()</td></tr>
<tr class="memdesc:a8d625eb609e0d9eb8b0a5f46aaa5cfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the refresh_rate attribute of this node's parameter  <a href="#a8d625eb609e0d9eb8b0a5f46aaa5cfe4">More...</a><br/></td></tr>
<tr class="separator:a8d625eb609e0d9eb8b0a5f46aaa5cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829730f8aba976b9acdf727a0e5ea993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a829730f8aba976b9acdf727a0e5ea993">set_value_step_size</a> (double v)</td></tr>
<tr class="memdesc:a829730f8aba976b9acdf727a0e5ea993"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the value_step_size attribute of this node's parameter  <a href="#a829730f8aba976b9acdf727a0e5ea993">More...</a><br/></td></tr>
<tr class="separator:a829730f8aba976b9acdf727a0e5ea993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5cc7ee62f291cb95f23fb487b326a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#abc5cc7ee62f291cb95f23fb487b326a5">unset_value_step_size</a> ()</td></tr>
<tr class="memdesc:abc5cc7ee62f291cb95f23fb487b326a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsets the value_step_size attribute of this node's parameter  <a href="#abc5cc7ee62f291cb95f23fb487b326a5">More...</a><br/></td></tr>
<tr class="separator:abc5cc7ee62f291cb95f23fb487b326a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d318eb5753d673a4588be40cccff875"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a9d318eb5753d673a4588be40cccff875">get_value_step_size</a> ()</td></tr>
<tr class="memdesc:a9d318eb5753d673a4588be40cccff875"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the value_step_size attribute of this node's parameter  <a href="#a9d318eb5753d673a4588be40cccff875">More...</a><br/></td></tr>
<tr class="separator:a9d318eb5753d673a4588be40cccff875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffb9699553282d69321c96561c8e448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a5ffb9699553282d69321c96561c8e448">set_priority</a> (float v)</td></tr>
<tr class="memdesc:a5ffb9699553282d69321c96561c8e448"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the priority attribute of this node's parameter  <a href="#a5ffb9699553282d69321c96561c8e448">More...</a><br/></td></tr>
<tr class="separator:a5ffb9699553282d69321c96561c8e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5142b9bbdac9b4db383bae26d6a2fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae5142b9bbdac9b4db383bae26d6a2fbc">unset_priority</a> ()</td></tr>
<tr class="memdesc:ae5142b9bbdac9b4db383bae26d6a2fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsets the priority attribute of this node's parameter  <a href="#ae5142b9bbdac9b4db383bae26d6a2fbc">More...</a><br/></td></tr>
<tr class="separator:ae5142b9bbdac9b4db383bae26d6a2fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad317094d31e448d2df599cf99f81823e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad317094d31e448d2df599cf99f81823e">get_priority</a> ()</td></tr>
<tr class="memdesc:ad317094d31e448d2df599cf99f81823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the priority attribute of this node's parameter  <a href="#ad317094d31e448d2df599cf99f81823e">More...</a><br/></td></tr>
<tr class="separator:ad317094d31e448d2df599cf99f81823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec186a96692362bd2604ce55e8baacc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aec186a96692362bd2604ce55e8baacc7">set_disabled</a> (bool v)</td></tr>
<tr class="memdesc:aec186a96692362bd2604ce55e8baacc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the disabled attribute of this node's parameter  <a href="#aec186a96692362bd2604ce55e8baacc7">More...</a><br/></td></tr>
<tr class="separator:aec186a96692362bd2604ce55e8baacc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f20966ecadcea7b4947f43225546349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1f20966ecadcea7b4947f43225546349">get_disabled</a> () const </td></tr>
<tr class="memdesc:a1f20966ecadcea7b4947f43225546349"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the disabled attribute of this node's parameter  <a href="#a1f20966ecadcea7b4947f43225546349">More...</a><br/></td></tr>
<tr class="separator:a1f20966ecadcea7b4947f43225546349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa268eb2bfa565d577e5ef0e99f2fb37b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aa268eb2bfa565d577e5ef0e99f2fb37b">set_muted</a> (bool v)</td></tr>
<tr class="memdesc:aa268eb2bfa565d577e5ef0e99f2fb37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the muted attribute of this node's parameter  <a href="#aa268eb2bfa565d577e5ef0e99f2fb37b">More...</a><br/></td></tr>
<tr class="separator:aa268eb2bfa565d577e5ef0e99f2fb37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47279e10a4edd1f4bcbf3fcf27cec5bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a47279e10a4edd1f4bcbf3fcf27cec5bd">get_muted</a> () const </td></tr>
<tr class="memdesc:a47279e10a4edd1f4bcbf3fcf27cec5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the muted attribute of this node's parameter  <a href="#a47279e10a4edd1f4bcbf3fcf27cec5bd">More...</a><br/></td></tr>
<tr class="separator:a47279e10a4edd1f4bcbf3fcf27cec5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a8b27164ee20b7fa60b1a8f1d76346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ab2a8b27164ee20b7fa60b1a8f1d76346">set_critical</a> (bool v)</td></tr>
<tr class="memdesc:ab2a8b27164ee20b7fa60b1a8f1d76346"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the critical attribute of this node's parameter  <a href="#ab2a8b27164ee20b7fa60b1a8f1d76346">More...</a><br/></td></tr>
<tr class="separator:ab2a8b27164ee20b7fa60b1a8f1d76346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca36321ad2ea77c51c8902608eb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ad1ca36321ad2ea77c51c8902608eb32c">get_critical</a> () const </td></tr>
<tr class="memdesc:ad1ca36321ad2ea77c51c8902608eb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the critical attribute of this node's parameter  <a href="#ad1ca36321ad2ea77c51c8902608eb32c">More...</a><br/></td></tr>
<tr class="separator:ad1ca36321ad2ea77c51c8902608eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae930fe69f98c7f0154247131fab1fa0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#ae930fe69f98c7f0154247131fab1fa0d">set_description</a> (std::string v)</td></tr>
<tr class="memdesc:ae930fe69f98c7f0154247131fab1fa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets this node's description attribute  <a href="#ae930fe69f98c7f0154247131fab1fa0d">More...</a><br/></td></tr>
<tr class="separator:ae930fe69f98c7f0154247131fab1fa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44280213adbb0c2395e2a2499eff4010"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a44280213adbb0c2395e2a2499eff4010">get_description</a> () const </td></tr>
<tr class="memdesc:a44280213adbb0c2395e2a2499eff4010"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets this node's description attribute  <a href="#a44280213adbb0c2395e2a2499eff4010">More...</a><br/></td></tr>
<tr class="separator:a44280213adbb0c2395e2a2499eff4010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefe6f4f39596801fd2c89e49e63092f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#acefe6f4f39596801fd2c89e49e63092f">set_tags</a> (std::vector&lt; std::string &gt; v)</td></tr>
<tr class="memdesc:acefe6f4f39596801fd2c89e49e63092f"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets his node's tags attribute  <a href="#acefe6f4f39596801fd2c89e49e63092f">More...</a><br/></td></tr>
<tr class="separator:acefe6f4f39596801fd2c89e49e63092f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b453ae63f432da61877642e3b8caedf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a8b453ae63f432da61877642e3b8caedf">get_tags</a> () const </td></tr>
<tr class="memdesc:a8b453ae63f432da61877642e3b8caedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets this node's tags attribute  <a href="#a8b453ae63f432da61877642e3b8caedf">More...</a><br/></td></tr>
<tr class="separator:a8b453ae63f432da61877642e3b8caedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1836487fbe99eecbde259df3c5fa65e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1836487fbe99eecbde259df3c5fa65e8">set_instance_bounds</a> (int min, int max)</td></tr>
<tr class="memdesc:a1836487fbe99eecbde259df3c5fa65e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets how many instances this node can have  <a href="#a1836487fbe99eecbde259df3c5fa65e8">More...</a><br/></td></tr>
<tr class="separator:a1836487fbe99eecbde259df3c5fa65e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77835c9874d598c9b4bb79df13b148b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a77835c9874d598c9b4bb79df13b148b1">unset_instance_bounds</a> ()</td></tr>
<tr class="memdesc:a77835c9874d598c9b4bb79df13b148b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">unset how many instances this node can have  <a href="#a77835c9874d598c9b4bb79df13b148b1">More...</a><br/></td></tr>
<tr class="separator:a77835c9874d598c9b4bb79df13b148b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf68c0e8a944757b74f9e12f8cdc413"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aadf68c0e8a944757b74f9e12f8cdc413">get_instance_bounds</a> () const </td></tr>
<tr class="memdesc:aadf68c0e8a944757b74f9e12f8cdc413"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets how many instances this node can have  <a href="#aadf68c0e8a944757b74f9e12f8cdc413">More...</a><br/></td></tr>
<tr class="separator:aadf68c0e8a944757b74f9e12f8cdc413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae1f19d549d40773c5a992d6de1ac01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a7ae1f19d549d40773c5a992d6de1ac01">set_hidden</a> (bool v)</td></tr>
<tr class="memdesc:a7ae1f19d549d40773c5a992d6de1ac01"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets this node's hidden attribute  <a href="#a7ae1f19d549d40773c5a992d6de1ac01">More...</a><br/></td></tr>
<tr class="separator:a7ae1f19d549d40773c5a992d6de1ac01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0526a43923c34ce0733bb334d79948b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a0526a43923c34ce0733bb334d79948b3">get_hidden</a> () const </td></tr>
<tr class="memdesc:a0526a43923c34ce0733bb334d79948b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets this node's hidden attribute  <a href="#a0526a43923c34ce0733bb334d79948b3">More...</a><br/></td></tr>
<tr class="separator:a0526a43923c34ce0733bb334d79948b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eea73b76438a846c24b9ad6d8979c7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a1eea73b76438a846c24b9ad6d8979c7c">get_zombie</a> () const </td></tr>
<tr class="memdesc:a1eea73b76438a846c24b9ad6d8979c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the zombie attribute of this node's parameter  <a href="#a1eea73b76438a846c24b9ad6d8979c7c">More...</a><br/></td></tr>
<tr class="separator:a1eea73b76438a846c24b9ad6d8979c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee43e109616bc5e00301879c326614a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#aee43e109616bc5e00301879c326614a1">load_preset</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:aee43e109616bc5e00301879c326614a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">load_preset: load JSON preset from a file  <a href="#aee43e109616bc5e00301879c326614a1">More...</a><br/></td></tr>
<tr class="separator:aee43e109616bc5e00301879c326614a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc67f3631f7b66a78f5207720cc0ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#afbc67f3631f7b66a78f5207720cc0ca9">save_preset</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:afbc67f3631f7b66a78f5207720cc0ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">save_preset: save JSON preset to a file  <a href="#afbc67f3631f7b66a78f5207720cc0ca9">More...</a><br/></td></tr>
<tr class="separator:afbc67f3631f7b66a78f5207720cc0ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5a2803b4166143fbec6b506a29c5f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classossia_1_1net_1_1node__base.html">ossia::net::node_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopp_1_1node.html#a9a5a2803b4166143fbec6b506a29c5f5">get_raw_node_pointer</a> ()</td></tr>
<tr class="memdesc:a9a5a2803b4166143fbec6b506a29c5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw node pointer.  <a href="#a9a5a2803b4166143fbec6b506a29c5f5">More...</a><br/></td></tr>
<tr class="separator:a9a5a2803b4166143fbec6b506a29c5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a44f7569b5e9d35608e02f84bbc5ccb2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopp_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assign the current node to another one </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the assigned node </dd></dl>

</div>
</div>
<a class="anchor" id="ac720f0af630b8ee27619022d64c541b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">opp::node::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks is the node is valid </p>
<dl class="section return"><dt>Returns</dt><dd>true if the node is valid </dd></dl>

</div>
</div>
<a class="anchor" id="ad8dd382212d8d830084656efef3190aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::request_add_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send to the device a request to add a node. </p>
<p>This is only relevant on node that belongs to a mirrored device </p>

</div>
</div>
<a class="anchor" id="af2fe2cfb25a1fb0c26881876fdd1cb62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::request_remove_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send to the device a request to remove a node. </p>
<p>This is only relevant on node that belongs to a mirrored device </p>

</div>
</div>
<a class="anchor" id="ad309987a47ab61fd8023ebc50311e0b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::request_rename_child </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send to the device a request to rename a node. </p>
<p>This is only relevant on node that belongs to a mirrored device </p>

</div>
</div>
<a class="anchor" id="a59b7cf6cff4f3bcf97e9dcf730d95707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string opp::node::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a node's name </p>
<dl class="section return"><dt>Returns</dt><dd>a string with the node's name </dd></dl>

</div>
</div>
<a class="anchor" id="aeb66c9f170ebc2a704d7e45e25df6502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set or change a node's name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>string with the desired node name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a490e8b8155fcffada9be090368ade3c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::has_parameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does this node have a parameter ? </p>
<dl class="section return"><dt>Returns</dt><dd>true if there is a parameter to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a0898906d92b158618fd53a4a4c4c6d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string opp::node::get_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get this node's OSC address </p>
<dl class="section return"><dt>Returns</dt><dd>this node's OSC address as a string </dd></dl>

</div>
</div>
<a class="anchor" id="a4a26286850558fcaf8b304d7b753ee62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classopp_1_1node.html">node</a> &gt; opp::node::get_namespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return all children recursively by priority order </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbd7d5930a562174fec29e4ec3d4ecbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classopp_1_1node.html">node</a> &gt; opp::node::get_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns all direct children (one level of hierarchy only) </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9897c17755170e995a681b5bbf795eab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::find_child </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds a child node by its name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is a string corresponding to the desired child node's name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child node </dd></dl>

</div>
</div>
<a class="anchor" id="ad5d82ff02da7d00e7787481435596e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classopp_1_1node.html">node</a> &gt; opp::node::find_children </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds children matching pattern </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>found children vector </dd></dl>

</div>
</div>
<a class="anchor" id="a77be428f953d8d37cab93661d38e5167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::remove_child </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes a child node, described by its name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>a string corresponding to the child node's name that one wants to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfb9c02fc885c71bb5eb27306c54270e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_child </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node to the current node this creates a "container", without a parameter, which can later be added with the set_(type) methods below </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is a string to use as the child's node name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the just-created node object </dd></dl>

</div>
</div>
<a class="anchor" id="ad75278a72b02d719b463d6d4ec7b393a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_impulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds an impulse parameter to the current node </p>
<p><a class="el" href="class_impulse.html">Impulse</a>: no value; just a message. </p>

</div>
</div>
<a class="anchor" id="aa4ba6cceb326ea94f58f30e5572d3c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_char </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a char parameter to the current node </p>
<p>Char: 8-bit value </p>

</div>
</div>
<a class="anchor" id="a31d97abb3432934daaa5a091257cdff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_int </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds an int parameter to the current node </p>
<p>Integer: 32-bit int. </p>

</div>
</div>
<a class="anchor" id="aca270e3c6f937e83615a2e9993f672c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node </p>
<p>Floating-point: 32-bit float. </p>

</div>
</div>
<a class="anchor" id="a2afaba8803b4476a1fb16c2900bf3559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a bool parameter to the current node </p>
<p>Boolean: true/false. </p>

</div>
</div>
<a class="anchor" id="aef0d7da3e08a44a4f0f2ac4696f1c647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_vec2f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec2f parameter to the current node </p>
<p>Vec2f: As an optimisation, vec2f is a specific type for 2 floats </p>

</div>
</div>
<a class="anchor" id="a30667c3507527de20248bc70854a1ebb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_vec3f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node </p>
<p>Vec3f: As an optimisation, vec3f is a specific type for 3 floats </p>

</div>
</div>
<a class="anchor" id="a36b5c172a370ac74b898147be8c1a3bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_vec4f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node </p>
<p>Vec4f: As an optimisation, vec4f is a specific type for 4 floats </p>

</div>
</div>
<a class="anchor" id="a539135ec52358a1ca5e02d3ca7b1be38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a list parameter to the current node </p>
<p>List: : a generic list of values: [3, 'a', 2.68, ["foo", "bar"]] </p>

</div>
</div>
<a class="anchor" id="ae87c1f18160af863524ce33e5374f07a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a string parameter to the current node </p>
<p>String: a string of chars as defined in the C++ standard library </p>

</div>
</div>
<a class="anchor" id="a027606c2c4eafe0faaa217ce3911e52f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a buffer parameter to the current node </p>
<p>Generic buffer : when a string should be interpreted as a a raw binary blob. </p>

</div>
</div>
<a class="anchor" id="afc366bf39b2877e507458f2b39b0432d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_filepath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a filepath parameter to the current node </p>
<p>File path : used for when a string is a filesystem path, like /home/self/sound.wav or c:\document.txt </p>

</div>
</div>
<a class="anchor" id="a490ef6a0aae958771f5956d6347b8000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_rgb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the color.rgb unit </p>
<p>RGB: 3 float numbers between 0. and 1. describing respectively Red, Green and Blue color values </p>

</div>
</div>
<a class="anchor" id="ac15f01fb5dd52bc0a065174cbf11d64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_rgba </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node, with the color.rgba unit </p>
<p>RGBA: 4 float numbers between 0. and 1. describing respectively Red, Green, Blue and Alpha color values </p>

</div>
</div>
<a class="anchor" id="a00ac29541f4ef1d5780379a717421105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_argb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node, with the color.argb unit </p>
<p>ARGB: 4 float numbers between 0. and 1. describing respectively Alpha, Red, Green and Blue color values </p>

</div>
</div>
<a class="anchor" id="a8eef6047e8fa99aca4306438d51f5af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_argb8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node, with the color.argb8 unit </p>
<p>8 bits ARGB: 4 int numbers between 0 and 255 describing respectively Alpha, Red, Green and Blue color values </p>

</div>
</div>
<a class="anchor" id="a1eee15d669d11fcae8ba65c2e85adbf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_rgba8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node, with the color.rgba8 unit </p>
<p>RGBA8: 4 int numbers between 0 and 255 describing respectively Red, Green, Blue and Alpha color values </p>

</div>
</div>
<a class="anchor" id="ae7815d8070ac3426c530d69033f06332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_hsv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the color.hsv unit </p>
<p>HSV: 3 float numbers between 0. and 1. describing respectively Hue, Saturation and Value (Luminosity) color values in the HSV colorspace </p>

</div>
</div>
<a class="anchor" id="a32b95aa1a538771848ff32631cb95207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_cart2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec2f parameter to the current node, with the position.cart2D unit </p>
<p>Cart2D: Cartesian 2-dimensional position (i.e. X, Y) </p>

</div>
</div>
<a class="anchor" id="ade0feb7b2d4c1911bfbdb649a6e5a923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_cart3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the position.cart3D unit </p>
<p>Cart3D: Cartesian 3-dimensional position (ie. X, Y, Z) </p>

</div>
</div>
<a class="anchor" id="aa9b7aacf69c98576c086fbce78c98d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_opengl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the position.openGL unit (aka X, Y, Z) </p>
<p>OpenGL: Cartesian 3-dimensional position (ie. X, Y, Z) in the OpenGL coordinate reference system </p>

</div>
</div>
<a class="anchor" id="a69d7ddf143b1e5959ffe75fd4bfd5fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_polar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec2f parameter to the current node, with the position.polar unit </p>
<p>Polar: Polar 2-dimensional position (ie. rp: radial distance, inclination angle, azimuth angle)) </p>

</div>
</div>
<a class="anchor" id="a2bf5c36e2f1e5ad68243f0ea84e11af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_spherical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the position.spherical unit (aka aed) </p>
<p>Spherical: Polar 3-dimensional position (ie. rtp: radial distance, inclination angle, azimuth angle) </p>

</div>
</div>
<a class="anchor" id="ad4e4ba44250360236009803d8ae265c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_cylindrical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the position.cylindrical unit (aka daz) </p>
<p>Cylindrical: Mixed 3-dimensional position (ie. rpz: radial distance, azimuth angle, height (Z)) </p>

</div>
</div>
<a class="anchor" id="a2d42ade9b80e91ea70f0e386059cbae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_angle_radian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cadds a vec3f parameter to the current node, with the angle.radian unit </p>
<p>radian: a angle expressed in radian </p>

</div>
</div>
<a class="anchor" id="ac2976c4fbf366ec584f784c4520cc0f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_angle_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with theangle.radian unit </p>
<p>degree: a angle expressed in degrees </p>

</div>
</div>
<a class="anchor" id="a1b117ed3ec9f7b647ca11f8237a1c1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_quaternion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node, with the orientation.quaternion unit </p>
<p>Quaternion: An extension of the complex numbers for 3D orientation, in the form a+bi+cj+dk </p>

</div>
</div>
<a class="anchor" id="abe8954fca7c67f310b91ac91e8986295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_euler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec3f parameter to the current node, with the orientation.euler unit (aka Euler angles) </p>
<p>Euler: A triplet of angles (in degrees) describing the orientation of a rigid body with respect to a fixed coordinate system </p>

</div>
</div>
<a class="anchor" id="aefd4da261c09419e2cdd0b9f5d271852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_axis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a vec4f parameter to the current node, with the orientation.axis unit </p>
<p>Axis: An angle (a, in degrees) relative to a 3-dimensional vector, expressed in the order X, Y, Z, w </p>

</div>
</div>
<a class="anchor" id="ad35739d903577f2f66f864859731f088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_decibel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node, with the gain.decibel unit </p>
<p>deciBel: a single float value expressed in a logarithmic scale, typically to describe an audio gain (0dB being the nominal gain, &lt;0dB describing a signal attenuation) </p>

</div>
</div>
<a class="anchor" id="a75c28b31d17a1b1ea7aec145273bbde0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_midigain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node, with the gain.midigain unit </p>
<p>midigain: a value in the [0 127] range mimicing a MIDI gain controller. 100 for the nominal level, 127 for +12dB </p>

</div>
</div>
<a class="anchor" id="ae5ad7e58b22a66c466d825441452d378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_linear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node, with the gain.linear unit </p>
<p>linear: a linear gain in the [0. 1.) range, with 1. being the nominal level </p>

</div>
</div>
<a class="anchor" id="acb66b95bce65be84941e4d05de8ee059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_frequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node, with the time.frequency unit </p>
<p>frequency: a frequency expressed in Hertz </p>

</div>
</div>
<a class="anchor" id="a1b4d460ee0825745cac5b990360aa18b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_midi_pitch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node, with the time.midi_pitch unit </p>
<p>midi_pitch: a frequency expressed as a MIDI pitch (ie. 36 for C3) </p>

</div>
</div>
<a class="anchor" id="a3a6694dae2bd1186c7ed24051beae680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::set_bpm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a float parameter to the current node, with the time.bpm unit </p>
<p>bpm: a frequency expressed in beats per minute </p>

</div>
</div>
<a class="anchor" id="a1c3bf8a9cd2823f4cd795cf107a0d119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_void </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with the name, and without parameter </p>
<p>Void: no value, no message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="aeb736d9ea4ef15ef0e4c4c87371e4db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_impulse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and an impulse parameter </p>
<p><a class="el" href="class_impulse.html">Impulse</a>: no value; just a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ab46e370c1786d6a4964993bee6ceb485"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_char </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a char parameter </p>
<p>Char: 8-bit char. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="adb77902e4063de66933787f41c4eaa45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_int </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and an int parameter </p>
<p>Integer: 32-bit int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a4db8d89f5bca2c401c046346519edbae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_float </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter </p>
<p>Floating-point: 32-bit float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a3fc4bbe26e5300368bea361276e4cc22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_bool </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a bool parameter </p>
<p>Boolean: true/false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a46028a8cdf143ac6812ddaf1973fe154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_vec2f </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec2f parameter </p>
<p>Vec2f: As an optimisation, vec2f is a specific type for 2 floats </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ad84877d7ecdc5bd71cbe97f0cce6f6ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_vec3f </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter </p>
<p>Vec3f: As an optimisation, vec3f is a specific type for 3 floats </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="aee9ebd44ba021e25993cbd2206f095e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_vec4f </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter </p>
<p>Vec4f: As an optimisation, vec4f is a specific type for 4 floats </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ad6ef9668c57839687b1af326e7e060d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_list </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a list parameter </p>
<p>List: : a generic list of values: [3, 'a', 2.68, ["foo", "bar"]] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ae28c792aebb371a1fd43131afc3c01bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a string parameter </p>
<p>String: a string of chars as defined in the C++ standard library </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a059e3f624fdab4a0fe2016324c172b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_buffer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a buffer parameter </p>
<p>Generic buffer : when a string should be interpreted as a a raw binary blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a89837e94060208ccac7b52d89be58bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_filepath </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a filepath parameter </p>
<p>File path : used for when a string is a filesystem path, like /home/self/sound.wav or c:\document.txt </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a9bb6f08c22080d5ae627b1dff18b1bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_rgb </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the color.rgb unit </p>
<p>RGB: 3 float numbers between 0. and 1. describing respectively Red, Green and Blue values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ada68b7aff298c4f2b3369f2d4c3f59f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_rgba </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter with the color.rgba unit </p>
<p>RGBA: 4 float numbers between 0. and 1. describing respectively Red, Green, Blue and Alpha values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="af3caafad80f96913de7848afb7d4b942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_rgba8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter with the color.rgba8 unit </p>
<p>RGBA8: 4 int numbers between 0 and 255 describing respectively Red, Green, Blue and Alpha values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a711c0b9c1acb134946e7ec96d53aa489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_argb </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter with the color.argb unit </p>
<p>ARGB: 4 float numbers between 0. and 1. describing respectively Alpha, Red, Green and Blue values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a5f554835042c0baa86dc6ce1b3035b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_argb8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter with the color.argb8 unit </p>
<p>8 bits ARGB: 4 int numbers between 0 and 255 describing respectively Alpha, Red, Green and Blue values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a257218faa82e5ffd4196e285232e3f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_hsv </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the color.hsv unit </p>
<p>HSV: 3 float numbers between 0. and 1. describing respectively Hue, Saturation and Value (Luminosity) values in the HSV colorspace </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ad97a8b0d8efb3546e7f01ba71755d9c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_cart2D </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec2f parameter with the position.cart2D unit (aka xy) </p>
<p>Cart2D: Cartesian 2-dimensional position (i.e. X, Y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="aee2b1b7b26fdca0bab2767b2dd08e3f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_cart3D </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the position.cart3D unit (aka XYZ) </p>
<p>Cart3D: Cartesian 3-dimensional position (ie. X, Y, Z) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a3517a8b4ed5089aac17f7d2eacb8ccef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_opengl </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the position.openGL unit (aka xyz) </p>
<p>OpenGL: Cartesian 3-dimensional position (ie. X, Y, Z) in the OpenGL coordinate reference system </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ad2170924f3a93e3710642ee3bf7fe19a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_polar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec2f parameter with the position.polar unit (aka rp) </p>
<p>Polar: Polar 2-dimensional position (ie. rp: radial distance, inclination angle, azimuth angle)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a245fb71f60d9fb96698a2d6535ab2e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_spherical </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the position.spherical unit (aka rtp) </p>
<p>Spherical: Polar 3-dimensional position (ie. rtp: radial distance, inclination angle, azimuth angle) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a1f1d806fcbed4c6c95b8af2b6f2cc1b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_cylindrical </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the position.cylindrical unit (aka rpz) </p>
<p>Cylindrical: Mixed 3-dimensional position (ie. rpz: radial distance, azimuth angle, height (Z)) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a18e7499f93905d61fbf13ff2bcdb820c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_angle_radian </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the angle.radian unit </p>
<p>Radian: a angle expressed in radian </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a7078259ab9d448dab27d3f1cf7768b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_angle_degree </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the angle.radian unit </p>
<p>Degree: a angle expressed in degrees </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a568d88c575f9ae9b85d458286cd0a9d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_quaternion </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter with the orientation.quaternion unit </p>
<p>Quaternion: An extension of the complex numbers for 3D orientation, in the form a+bi+cj+dk </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a5110b70106cf9b8a7cf7bcc120e7067d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_euler </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec3f parameter with the orientation.euler unit (aka Euler angles) </p>
<p>Euler: A triplet of angles (in degrees): {yaw, pitch, roll} describing the orientation of a rigid body with respect to a fixed coordinate system </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a8a0b798db44c974a41e611fe0997bde7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_axis </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a vec4f parameter with the orientation.axis unit (aka xyza) </p>
<p>Axis: An angle (w, in degrees) relative to a 3-dimensional vector, expressed in the order X, Y, Z, w </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="afa6fdd94ded768b7fdf2ec119215d870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_decibel </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the gain.decibel unit </p>
<p>deciBel: a single float value expressed in a logarithmic scale, typically to describe an audio gain (0dB being the nominal gain, &lt;0dB describing a signal attenuation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a5703d04ae9da8a7bc3c61c6b9f295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_midigain </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the gain.midigain unit in the [0 127) range </p>
<p>midigain: a value in the [0 127] range mimicing a MIDI gain controller. 100 for the nominal level, 127 for +12dB </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a324b20d2dd52b82f30dd8a3ab3648027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_linear </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the gain.linear unit in the [0. 1.) range </p>
<p>linear: a linear gain in the [0. 1.) range, with 1. being the nominal level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a94434d277319ca9634c7606fd9e4de7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_frequency </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the time.frequency unit </p>
<p>frequency: a frequency expressed in Hertz </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a9710c3a9d3e08e321a60504412aab10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_midi_pitch </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the time.midi_pitch unit </p>
<p>midi_pitch: a frequency expressed as a MIDI pitch (ie. 36 for C3) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a6f659cd38bff0e580720c5ecd28112b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> opp::node::create_bpm </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a child node with tne given name, and a float parameter with the time.bpm unit </p>
<p>bpm: a frequency expressed in beats per minute </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>the name of the created node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created <a class="el" href="classopp_1_1node.html" title="The node class holds all ossia nodes and their optional parameters. ">opp::node</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a08508d1e965f2df41ae7c988bce9306e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the node's parameter's value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an opp:value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae38746c9de30e9f3a066ac22d625367a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1value.html">value</a> opp::node::get_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get this node's (local) parameter's value </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with this node's parameter's value </dd></dl>

</div>
</div>
<a class="anchor" id="af79bf1415b202d1704d4e13569be8a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1value.html">value</a> opp::node::fetch_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fetch this node's parameter's value over the network: </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with this node's parameter's value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1oscquery__mirror.html" title="The oscquery_mirror class allows to create a mirror image of a remote OSCQuery server. ">opp::oscquery_mirror</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80bd2b81241d90f8b3e2c5e223063442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopp_1_1callback__index.html">callback_index</a> opp::node::set_value_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopp.html#a0a4d1fcb27d12c990c5f5fe78a7c0b35">value_callback</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets a callback allowing to listen to this value </p>
<p>Parameter callbacks will inform you every time a parameter receives a message: this will enable listening on the remote end, ie. messages will be sent upon modification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a value_callback </td></tr>
    <tr><td class="paramname">ctx</td><td>the context as a void* </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structopp_1_1callback__index.html" title="The callback_index struct holds callbacks for adding listeners to parameters&#39; values. ">callback_index</a> struct </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceopp.html#a0a4d1fcb27d12c990c5f5fe78a7c0b35" title="container for a value callback ">opp::value_callback</a> </dd>
<dd>
<a class="el" href="structopp_1_1callback__index.html" title="The callback_index struct holds callbacks for adding listeners to parameters&#39; values. ">opp::callback_index</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22be6e0f63fad29a8c34803aa8102986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::remove_value_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structopp_1_1callback__index.html">callback_index</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes a value_callback, previously set with <a class="el" href="classopp_1_1node.html#a80bd2b81241d90f8b3e2c5e223063442" title="sets a callback allowing to listen to this value ">set_value_callback()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>a <a class="el" href="structopp_1_1callback__index.html" title="The callback_index struct holds callbacks for adding listeners to parameters&#39; values. ">callback_index</a>, as returned by <a class="el" href="classopp_1_1node.html#a80bd2b81241d90f8b3e2c5e223063442" title="sets a callback allowing to listen to this value ">set_value_callback()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structopp_1_1callback__index.html" title="The callback_index struct holds callbacks for adding listeners to parameters&#39; values. ">opp::callback_index</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ff22b0fcbb21f65b0b6e7a87e306ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopp.html#a8b693d7ac4659eabc37b56a8e8565ff3">access_mode</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the access_mode attribute of this node's parameter </p>
<p>Access mode is a metadata that categorizes parameters between:</p>
<ul>
<li>GET: read-only</li>
<li>SET: write-only</li>
<li>BI: read-write</li>
</ul>
<p>For instance:</p>
<ul>
<li>The value of a vu-meter should be GET</li>
<li>A "play" button should be SET.</li>
<li>The cutoff of a filter or a controllable color should be BI. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an <a class="el" href="namespaceopp.html#a8b693d7ac4659eabc37b56a8e8565ff3" title="Defines Write (Set), Read (Get) or Read/Write (Bi) access to the parameter&#39;s value. ">opp::access_mode</a> of the chosen mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a94ef5059c3ecbbe039ab77ae4f6fbeec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopp.html#a8b693d7ac4659eabc37b56a8e8565ff3">access_mode</a> opp::node::get_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the access_mode attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="namespaceopp.html#a8b693d7ac4659eabc37b56a8e8565ff3" title="Defines Write (Set), Read (Get) or Read/Write (Bi) access to the parameter&#39;s value. ">opp::access_mode</a> with this node's parameter's access mode </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>opp::node::set_acess </dd></dl>

</div>
</div>
<a class="anchor" id="afe0ba8f99bc33e21d8b6665f495dc039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td>
          <td class="paramname"><em>min</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the 'min' attribute of this node's parameter (minimum value) </p>
<p>Domains allow to set a range of accepted values for a given parameter.<br/>
 This range can be continuous (between a min and max), or discrete: a set of accepted values.<br/>
 This function defines the minimum of a continuous range.<br/>
 This is only meaningful for nodes with parameters of numerical types (ie ints, floats, vecnfs and some lists)<br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with the desired minimum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#a9f33371530f5793628bbfc71d96c1af5" title="sets the bounding_mode attribute of this node&#39;s parameter ">opp::node::set_bounding</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aadcbfaecbef8831f2788684924530d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1value.html">value</a> opp::node::get_min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the 'min' attribute of this node's parameter (minimum value) </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with this node's parameter's minimum value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#afe0ba8f99bc33e21d8b6665f495dc039" title="sets the &#39;min&#39; attribute of this node&#39;s parameter (minimum value) ">opp::node::set_min</a> </dd>
<dd>
<a class="el" href="classopp_1_1node.html#afb32fcd277d7ee4f908e241fb8f86157" title="gets the bounding_mode attribute of this node&#39;s parameter ">opp::node::get_bounding</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad35bdf42f8c92e33b749e01f5c2298e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopp_1_1value.html">opp::value</a>&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the 'max' attribute of this node's parameter (maximum value) </p>
<p>Domains allow to set a range of accepted values for a given parameter.<br/>
 This range can be continuous (between a min and max), or discrete: a set of accepted values.<br/>
 This function defines the maximum of a continuous range.<br/>
 This is only meaningful for nodes with parameters of numerical types (ie ints, floats, vecnfs and some lists)<br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with the desired mmaximum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#a9f33371530f5793628bbfc71d96c1af5" title="sets the bounding_mode attribute of this node&#39;s parameter ">opp::node::set_bounding</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6bdb5eb32560bd54fafd8ee5ff64546d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1value.html">value</a> opp::node::get_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the 'max' attribute of this node's parameter (maximum value) </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with this node's parameter's maximum value </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#ad35bdf42f8c92e33b749e01f5c2298e2" title="sets the &#39;max&#39; attribute of this node&#39;s parameter (maximum value) ">opp::node::set_max</a> </dd>
<dd>
<a class="el" href="classopp_1_1node.html#afb32fcd277d7ee4f908e241fb8f86157" title="gets the bounding_mode attribute of this node&#39;s parameter ">opp::node::get_bounding</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af8e2c36e5563f9b6477dde20307ef4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_accepted_values </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classopp_1_1value.html">opp::value</a> &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets a list of the values accepted by this node's parameter ("values" attribute) </p>
<p>Domains allow to set a range of accepted values for a given parameter.<br/>
 This range can be continuous (between a min and max), or discrete: a set of accepted values.<br/>
 This function defines a set of accepted values.<br/>
 This is only meaningful for nodes with parameters of about any types except <a class="el" href="class_impulse.html">Impulse</a><br/>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with the desired list of accepted values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#a9f33371530f5793628bbfc71d96c1af5" title="sets the bounding_mode attribute of this node&#39;s parameter ">opp::node::set_bounding</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a75a6a123f32e57763a5b9c9826f6bdfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classopp_1_1value.html">value</a> &gt; opp::node::get_accepted_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets a list of the values accepted by this node's parameter ("values" attribute) </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with the list of this node's parameter's accepted values </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#af8e2c36e5563f9b6477dde20307ef4a3" title="sets a list of the values accepted by this node&#39;s parameter (&quot;values&quot; attribute) ">opp::node::set_accepted_values</a> </dd>
<dd>
<a class="el" href="classopp_1_1node.html#a9f33371530f5793628bbfc71d96c1af5" title="sets the bounding_mode attribute of this node&#39;s parameter ">opp::node::set_bounding</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f33371530f5793628bbfc71d96c1af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_bounding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopp.html#a928d0c64a8d475a1f454ed1b140ca954">bounding_mode</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the bounding_mode attribute of this node's parameter </p>
<p>The bounding mode tells what happens when a value is outside of the min / max:</p>
<ul>
<li><b>FREE</b> : no clipping; domain is only indicative.</li>
<li><b>CLIP</b> : clipped to the closest value in the range.</li>
<li><b>LOW</b> : only clips values lower than the min.</li>
<li><b>HIGH</b> : only clips values higher than the max.</li>
<li><b>WRAP</b> : wraps values around the range</li>
<li><b>FOLD</b> : folds back values into the range</li>
</ul>
<p>The default is <b>FREE</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an <a class="el" href="namespaceopp.html#a928d0c64a8d475a1f454ed1b140ca954" title="Behaviour at the bounds of the value. ">opp::bounding_mode</a> of the chosen mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classopp_1_1node.html#afe0ba8f99bc33e21d8b6665f495dc039" title="sets the &#39;min&#39; attribute of this node&#39;s parameter (minimum value) ">opp::node::set_min</a> </dd>
<dd>
<a class="el" href="classopp_1_1node.html#ad35bdf42f8c92e33b749e01f5c2298e2" title="sets the &#39;max&#39; attribute of this node&#39;s parameter (maximum value) ">opp::node::set_max</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb32fcd277d7ee4f908e241fb8f86157"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopp.html#a928d0c64a8d475a1f454ed1b140ca954">bounding_mode</a> opp::node::get_bounding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the bounding_mode attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="namespaceopp.html#a928d0c64a8d475a1f454ed1b140ca954" title="Behaviour at the bounds of the value. ">opp::bounding_mode</a> with this node's parameter's access mode </dd></dl>

</div>
</div>
<a class="anchor" id="a5b06de6a111af5996d4216ee8c8392c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_unit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the unit attribute of this node's parameter </p>
<p>Units give a semantic meaning to the value of a parameter. <br/>
 Units are sorted by categories (coined "dataspace" ): every unit in a category is convertible to the other units in the same category. <br/>
 Every category has a neutral unit to/from which conversions are made. <br/>
</p>
<p>An unit, when setting it as a parameter's attribute, can be expressed as a string in the form:<br/>
</p>
<ul>
<li>"category.unit" (such as "position.cart2D"),<br/>
</li>
<li>only with the unit name (such as "cart2D", those being all unique), <br/>
</li>
<li>or with "nicknames", that are indicated in parentheses, after the unit name <br/>
 A list of all supported units is given below.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a string with this unit's name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structossia_1_1unit__t.html">ossia::unit_t</a></dd></dl>
<ul>
<li><b>Position</b><ul>
<li><b>cart3D</b> (<em>xyz</em>, <em>pos</em>, <em>point</em>, <em>point3d</em>, <em>3d</em>, <em>cartesian3d</em>, <em>coord</em>, <em>coordinate</em>, <em>coordinates</em>, <em>pvector</em> *, <em>vertex</em>): Cartesian 3-dimensional position (ie. X, Y, Z) in the OpenGL coordinate reference system</li>
<li><b>cart2D</b> (<em>xy</em>, <em>complex</em>, <em>point2d</em>, <em>2d</em>, <em>cartesian2d</em>): Cartesian 2-dimensional position (i.e. X, Y)</li>
<li><b>opengl</b> (<em>gl</em>, <em>position.gl</em>): Cartesian 3-dimensional position (ie. X, Y, Z) in the OpenGL coordinate reference system</li>
<li><b>spherical</b> (<em>aed</em>): Polar 3-dimensional position (ie. aed: azimuth, elevation, distance)</li>
<li><b>polar</b> (<em>ad</em>): Polar 2-dimensional position (ie. ad: azimuth, distance)</li>
<li><b>cylindrical</b> (<em>daz</em>): Mixed 3-dimensional position (ie. daz: distance, azimuth, Z)</li>
</ul>
</li>
<li><b>Orientation</b><ul>
<li><b>quaternion</b>: An extension of the complex numbers for 3D orientation, in the form a+bi+cj+dk</li>
<li><b>euler</b>: A triplet of angles (in degrees) describing the orientation of a rigid body with respect to a fixed coordinate system</li>
<li><b>axis</b>: An angle (a, in degrees) relative to a 3-dimensional vector, expressed in the order X, Y, Z, a</li>
</ul>
</li>
<li><b>Color</b><ul>
<li><b>argb</b> (<em>col</em>): 4 float numbers between 0. and 1. describing respectively Alpha, Red, Green and Blue color values</li>
<li><b>rgba</b>: 4 float numbers between 0. and 1. describing respectively Red, Green, Blue and Alpha color values</li>
<li><b>rgb</b>: 3 float numbers between 0. and 1. describing respectively Red, Green and Blue color values</li>
<li><b>bgr</b>: 3 float numbers between 0. and 1. describing respectively Blue, Green and Red color values</li>
<li><b>argb8</b>: 4 int numbers between 0 and 255 describing respectively Alpha, Red, Green and Blue color values</li>
<li><b>hsv</b>: 3 float numbers between 0. and 1. describing respectively Hue, Saturation and Value (Luminosity) color values in the * HSV colorspace</li>
<li><b>cmy8</b>: 3 int numbers between 0 and 255 describing respectively Cyan, Magenta, and Yellow color values</li>
<li><b>cmyk8</b>: 4 int numbers between 0 and 255 describing respectively Cyan, Magenta, Yellow and Black color values</li>
</ul>
</li>
<li><b>Angle</b><ul>
<li><b>radian</b></li>
<li><b>degree</b></li>
</ul>
</li>
<li><b>Distance</b><ul>
<li><b>meter</b></li>
<li><b>kilometer</b></li>
<li><b>decimeter</b></li>
<li><b>centimeter</b></li>
<li><b>millimeter</b></li>
<li><b>micrometer</b></li>
<li><b>nanometer</b></li>
<li><b>picometer</b></li>
<li><b>inch</b></li>
<li><b>foot</b></li>
<li><b>mile</b></li>
</ul>
</li>
<li><b>Time</b><ul>
<li><b>second</b></li>
<li><b>bark</b></li>
<li><b>bpm</b></li>
<li><b>cent</b></li>
<li><b>frequency</b> (<em>freq</em>, <em>frequence</em>, <em>Hz</em>, <em>hz</em>, <em>Hertz</em>):</li>
<li><b>mel</b></li>
<li><b>midi_pitch</b> (<em>midinote</em>):</li>
<li><b>millisecond</b> (<em>ms</em>)</li>
<li><b>playback_speed</b></li>
<li><b>sample</b> (the length of a sample, for a sample_rate of 44100Hz)</li>
</ul>
</li>
<li><b>Gain</b><ul>
<li><b>linear</b>: A linear gain in the [0. 1.] range, with 1. being the nominal level</li>
<li><b>midigain</b>: A value in the [0 127] range mimicing a MIDI gain controller. 100 for the nominal level, 127 for +12dB</li>
<li><b>decibel</b> (<em>db</em>, <em>dB</em>): A single float value expressed in a logarithmic scale, typically to describe an audio gain (0dB being the nominal * gain, &lt; 0dB describing a signal attenuation, clipped at -96dB)</li>
<li><b>decibel_raw</b> Same as deciBel, but unclipped.</li>
</ul>
</li>
<li><b>Speed</b><ul>
<li><b>meter_per_second</b></li>
<li><b>miles_per_hour</b></li>
<li><b>kilometer_per_hour</b></li>
<li><b>knot</b></li>
<li><b>foot_per_second</b></li>
<li><b>foot_per_hour</b> </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a207ebec6efacf660025c4efa95473873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string opp::node::get_unit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the unit of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a string with this node's parameter's unit name </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structossia_1_1unit__t.html">ossia::unit_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae57cbd951ec099c0c30e31cfca40e392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_default_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopp_1_1value.html">value</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the default_value attribute of this node's parameter </p>
<p>A default value for a given node. Useful for resetting to a default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with this node's parameter's default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structossia_1_1unit__t.html">ossia::unit_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a958c29f69d0687edd03df7470c343fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1value.html">value</a> opp::node::get_default_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the default_value attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classopp_1_1value.html" title="The value class holds all ossia parameters typed values. ">opp::value</a> with this node's parameter's default value </dd></dl>

</div>
</div>
<a class="anchor" id="a168e29de264900d7392e37eafecaab1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_repetition_filter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the repetition_filter attribute of this node's parameter </p>
<p>When the repetition filter is enabled, if the same value is sent twice, the second time will be filtered out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an bool: true to filter out this node's parameter's value repetitions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a03bf84f55897dafa4ab2b6f431329a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::get_repetition_filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the repetition_filter attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a bool: true if this node's parameter's value repetitions are filtered out </dd></dl>

</div>
</div>
<a class="anchor" id="a2e16899e2e14b3ec239ec2222cc2872d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_refresh_rate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the refresh_rate attribute of this node's parameter </p>
<p>An optional value that says how often a value should be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>an int with this node's parameter's refresh_rate value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a2870761c0afafd835ce34a77a574b97d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::unset_refresh_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsets the refresh_rate attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a8d625eb609e0d9eb8b0a5f46aaa5cfe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int opp::node::get_refresh_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the refresh_rate attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a float with this node's parameter's refresh_rate value </dd></dl>

</div>
</div>
<a class="anchor" id="a829730f8aba976b9acdf727a0e5ea993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_value_step_size </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the value_step_size attribute of this node's parameter </p>
<p>An optional value that says by which increment a value should change, for instance in a value editor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the increment size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="abc5cc7ee62f291cb95f23fb487b326a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::unset_value_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsets the value_step_size attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a9d318eb5753d673a4588be40cccff875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double opp::node::get_value_step_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the value_step_size attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a float with this node's parameter's refresh_rate value </dd></dl>

</div>
</div>
<a class="anchor" id="a5ffb9699553282d69321c96561c8e448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_priority </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the priority attribute of this node's parameter </p>
<p>Nodes with the highest priority should execute first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a float with this node's parameter's priority value (higher numbers for higher priorities) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="ae5142b9bbdac9b4db383bae26d6a2fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::unset_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unsets the priority attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="ad317094d31e448d2df599cf99f81823e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float opp::node::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the priority attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a float with this node's parameter's priority value (higher numbers for higher priorities) </dd></dl>

</div>
</div>
<a class="anchor" id="aec186a96692362bd2604ce55e8baacc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_disabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the disabled attribute of this node's parameter </p>
<p>This attribute will disable a node: it will stop receiving and sending messages from/to the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a bool: true to disable this node's parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a1f20966ecadcea7b4947f43225546349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::get_disabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the disabled attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a bool: true if the node's parameter is disabled </dd></dl>

</div>
</div>
<a class="anchor" id="aa268eb2bfa565d577e5ef0e99f2fb37b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_muted </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the muted attribute of this node's parameter </p>
<p>This attribute will disable a node: it will stop sending messages to the network. <br/>
 Unlike the "disabled" attribute, it won't propagate to other mirrored servers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a bool: true to mute this node's parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a47279e10a4edd1f4bcbf3fcf27cec5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::get_muted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the muted attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a bool: true if the node's parameter is muted </dd></dl>

</div>
</div>
<a class="anchor" id="ab2a8b27164ee20b7fa60b1a8f1d76346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_critical </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the critical attribute of this node's parameter </p>
<p>This attribute informs the network protocol that the value has a particular importance and should if possible use a protocol not subject to message loss, eg TCP instead of UDP. This is useful for instance for "play" messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a bool: true to mark this node's parameter as critical </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="ad1ca36321ad2ea77c51c8902608eb32c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::get_critical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the critical attribute of this node's parameter </p>
<dl class="section return"><dt>Returns</dt><dd>a bool: true if the node's parameter is critical </dd></dl>

</div>
</div>
<a class="anchor" id="ae930fe69f98c7f0154247131fab1fa0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_description </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets this node's description attribute </p>
<p>An optional textual description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a string with the textual description of this node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a44280213adbb0c2395e2a2499eff4010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string opp::node::get_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets this node's description attribute </p>
<dl class="section return"><dt>Returns</dt><dd>a string with the textual description of this node </dd></dl>

</div>
</div>
<a class="anchor" id="acefe6f4f39596801fd2c89e49e63092f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_tags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets his node's tags attribute </p>
<p>An optional array of tags for nodes, expressed as one string per tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of strings with the desired tags of this node' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a8b453ae63f432da61877642e3b8caedf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; opp::node::get_tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets this node's tags attribute </p>
<dl class="section return"><dt>Returns</dt><dd>a string with this node's tags </dd></dl>

</div>
</div>
<a class="anchor" id="a1836487fbe99eecbde259df3c5fa65e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_instance_bounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets how many instances this node can have </p>
<p>For nodes that can have instantiatable children, this sets the minimum and maximum number of children that can exist. This is an optional attribute: it is not enforced and is only to be relied upon as a metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>the minimum number of instances this node can have </td></tr>
    <tr><td class="paramname">max</td><td>the maximum number of instances this node can have </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a77835c9874d598c9b4bb79df13b148b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::unset_instance_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unset how many instances this node can have </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="aadf68c0e8a944757b74f9e12f8cdc413"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; opp::node::get_instance_bounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets how many instances this node can have </p>
<dl class="section return"><dt>Returns</dt><dd>a std::pair with the minimum and maxium number sof instances this node can have </dd></dl>

</div>
</div>
<a class="anchor" id="a7ae1f19d549d40773c5a992d6de1ac01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopp_1_1node.html">node</a> &amp; opp::node::set_hidden </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets this node's hidden attribute </p>
<p>This attribute is to use for nodes that are not to be exposed to the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a bool: true to hide this node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this node </dd></dl>

</div>
</div>
<a class="anchor" id="a0526a43923c34ce0733bb334d79948b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::get_hidden </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets this node's hidden attribute </p>
<dl class="section return"><dt>Returns</dt><dd>a bool: true if the node is hidden </dd></dl>

</div>
</div>
<a class="anchor" id="a1eea73b76438a846c24b9ad6d8979c7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opp::node::get_zombie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the zombie attribute of this node's parameter </p>
<p>This is a read-only attribute: it informs of whether a node is in a zombie state. A zombie node is an node in a remote device, whose source has been removed. It is kept in the mirrors but marked as such. </p>
<dl class="section return"><dt>Returns</dt><dd>a bool: true if the node has been zombified </dd></dl>

</div>
</div>
<a class="anchor" id="aee43e109616bc5e00301879c326614a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::load_preset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load_preset: load JSON preset from a file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbc67f3631f7b66a78f5207720cc0ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opp::node::save_preset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save_preset: save JSON preset to a file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a5a2803b4166143fbec6b506a29c5f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classossia_1_1net_1_1node__base.html">ossia::net::node_base</a>* opp::node::get_raw_node_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the raw node pointer. </p>
<p>Be careful, this gives you great power and with great power comes... It's useful to make use of ossia feature that are not available in opp:: namespace (but requires some more computer skill) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceopp.html">opp</a></li><li class="navelem"><a class="el" href="classopp_1_1node.html">node</a></li>
    <li class="footer">Generated on Thu Feb 14 2019 10:06:48 for OSSIA by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
